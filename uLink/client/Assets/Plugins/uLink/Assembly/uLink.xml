<?xml version="1.0"?>
<doc>
  <assembly>
    <name>uLink</name>
  </assembly>
  <members>
    <member name="T:uLink.NetworkBufferedRPC">
      <summary>
            Represents a buffered message. 
            </summary>
      <remarks>
            Buffered messages is a uLink tool that can be used to give newly connected players all 
            the important RPCs they need to join a game that is already running.
            Read more about when to use this class in 
            uLink.Network.<see cref="!:uLink.Network.uLink_OnPreBufferedRPCs" /> 
            and the manual chapter about RPCs.
            </remarks>
    </member>
    <member name="M:uLink.NetworkBufferedRPC.DontExecuteOnConnected">
      <summary>
            Disable automatic execution before invoking uLink_ConnectedToServer().
            </summary>
      <remarks>Call this if you want to control the execution of buffered RPCs in clients.
            They can be executed at a later time by using the <see cref="M:uLink.NetworkBufferedRPC.ExecuteNow" /> or simply ignored. Also, 
            take at look at the documentation for the callback <see cref="!:uLink.Network.uLink_OnPreBufferedRPCs" /></remarks>
    </member>
    <member name="M:uLink.NetworkBufferedRPC.ExecuteNow">
      <summary>
            Executes the RPC. 
            </summary>
      <remarks>
            This will also call <see cref="M:uLink.NetworkBufferedRPC.DontExecuteOnConnected" /></remarks>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.sender">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> who sent the buffered message.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.timestamp">
      <summary>
            Gets the timestamp when this buffered message was first sent.
            </summary>
      <remarks>See <see cref="P:uLink.Network.time" />.
            </remarks>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.viewID">
      <summary>
            Gets the <see cref="T:uLink.NetworkViewID" /> for this buffered message.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.flags">
      <summary>
            The network flags that was used when this buffered message was sent.
            </summary>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.rpcName">
      <summary>
            Gets the name of this buffered RPC.
            </summary>
      <value>The name as a string. If it is an Instantiate RPC , this call will return an empty string. 
            See <see cref="P:uLink.NetworkBufferedRPC.isInstantiate" />.</value>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.isInstantiate">
      <summary>
            Gets a value indicating whether this buffered message is a uLink internal instantiate RPC.
            </summary>
      <value>
        <c>true</c> if this is Instantiate; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="P:uLink.NetworkBufferedRPC.isRPC">
      <summary>
            Gets a value indicating whether this buffered message is a user-defined RPC.
            </summary>
      <value>
        <c>true</c> if this is RPC; otherwise, <c>false</c>.
            </value>
    </member>
    <member name="T:uLink.LocalHostData">
      <summary>
            Base data structure for holding individual host (server) information, for a LAN server without an external IP address.
            </summary>
      <remarks>
            Host information for servers with and external public address is stored in the subclass <see cref="T:uLink.HostData" />.
            </remarks>
    </member>
    <member name="F:uLink.LocalHostData.gameType">
      <summary>
            The type of the game (like MyUniqueGameType).
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.gameName">
      <summary>
            The name of the game (like John Doe's Game)
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.gameMode">
      <summary>
            Use this string to describe the mode this game server is running (deathmatch, free for all..)
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.gameLevel">
      <summary>
            Use this string to describe the game level for the server.
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.connectedPlayers">
      <summary>
            Currently connected number of players
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.playerLimit">
      <summary>
            The maximum number of players that is allowed on this server.
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.passwordProtected">
      <summary>
            Does the server require a password?
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.dedicatedServer">
      <summary>
            Is the server dedicated or hosted by a player?
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.useNat">
      <summary>
            Does this server require NAT punchthrough?
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.useProxy">
      <summary>
            Does this server require that clients connect via a proxy?
            </summary>
      <remarks>
            Read more about the proxy server in the Master Server and Proxy manual chapter.
            </remarks>
    </member>
    <member name="F:uLink.LocalHostData.comment">
      <summary>
            A miscellaneous comment about the server
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.platform">
      <summary>
            Use this string to describe the platform needed for connecting to this game server.
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.timestamp">
      <summary>
            The time when this data (about the host) was collected.
            </summary>
    </member>
    <member name="F:uLink.LocalHostData.internalEndpoint">
      <summary>
            The IP address and port for this host in the local network (LAN). 
            </summary>
    </member>
    <member name="M:uLink.LocalHostData.IsDefined">
      <summary>
            Returns true if internalEnpoint, gameType and gameName has been set, otherwise false.
            </summary>
    </member>
    <member name="P:uLink.LocalHostData.internalPort">
      <summary>
            Server private port in the local network (LAN). 
            </summary>
    </member>
    <member name="P:uLink.LocalHostData.internalIP">
      <summary>
            Server private IP address in the local network (LAN). 
            </summary>
    </member>
    <member name="P:uLink.LocalHostData.port">
      <summary>
            Server private port in the local network (LAN). Same as <see cref="P:uLink.LocalHostData.internalPort" />.
            </summary>
    </member>
    <member name="P:uLink.LocalHostData.ipAddress">
      <summary>
            Server private IP address in the local network (LAN). Same as <see cref="P:uLink.LocalHostData.internalIP" />.
            </summary>
    </member>
    <member name="T:uLink.NetworkPrefs">
      <summary>
            Utility class used by the uLink menu in the Unity Editor.
            </summary>
    </member>
    <member name="T:uLink.NetworkConfig">
      <summary>
            Enables configuration of low-level network parameters, like connection timeouts, inactivity timeouts, ping frequency
            and MTU (Maximum Transmission Unit). See <see cref="P:uLink.Network.config" />. 
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.maximumTransmissionUnit">
      <summary>
            Gets or sets how many data bytes that can maximally be sent using a single UDP packet.
            This can be set independently for the client and the server.
            Only modify this if you know what you are doing. 
            The default value 1400 has been carefully chosen for optimal speed and 
            throughput in most link layers in IP networks. 
            The value 1400 will ensure that UDP packets with uLink traffic (data and all headders) fit into one single 
            ethernet frame (1500 max) and thus the packet loss risk will be minimal for every UDP packet.
            Ethernet is a very common link layer in modern IP networks.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.timeBetweenPings">
      <summary>
            Gets or sets the number of seconds between pings.
            This can be set independently for the client and the server.
            Default value is 3 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.timeoutDelay">
      <summary>
            Gets or sets the time in seconds before a connection times out when no network packets are received from remote host.
            This can be set independently for the client and the server. Default value is 30 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.handshakeRetriesMaxCount">
      <summary>
            Gets or sets the maximum number of re-attempts to connect to the remote host before giving up.
            This only has meaning for the client, or the connecting peer. Default value is 5 attempts.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.handshakeRetryDelay">
      <summary>
            Gets or sets the number of seconds between handshake attempts.
            This only has meaning for the client, or the connecting peer.
            Default value is 2.5 seconds.
            </summary>
    </member>
    <member name="P:uLink.NetworkConfig.batchSendAtEndOfFrame">
      <summary>
            Determines whether uLink should queue all outgoing messages until the end of frame.
            </summary>
      <remarks>
            Batching lets uLink do more optimizations such as fitting multiple messages in a single packet,
            if they are not too big. There will be a slight CPU and bandwidth cost for turning off batching,
            how much depends on the amount and type of messages.
            But one benefit of disabling it, is that you then know the message has been sent after <see cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" />
            has returned and CPU profiling of RPCs is more accurate, in Unity's Profiler. 
            </remarks>
    </member>
    <member name="F:uLink.NetworkGroup.unassigned">
      <summary>
            Represents an special network group which all players are always part of.
            </summary>
    </member>
    <member name="F:uLink.NetworkGroup.max">
      <summary>
            Maximum <see cref="P:uLink.NetworkGroup.id" /> value a assigned group can have.
            </summary>
    </member>
    <member name="F:uLink.NetworkGroup.min">
      <summary>
            Minimum <see cref="P:uLink.NetworkGroup.id" /> value a assigned group can have.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:uLink.NetworkGroup" /> struct.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_Equality(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkGroup" />s are identical
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_Inequality(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkGroup" />s are not identical
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_GreaterThanOrEqual(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkGroup" /> is greater than or equal to the right <see cref="T:uLink.NetworkGroup" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_LessThanOrEqual(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkGroup" /> is less than or equal to the right <see cref="T:uLink.NetworkGroup" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_GreaterThan(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkGroup" /> is greater than the right <see cref="T:uLink.NetworkGroup" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.op_LessThan(uLink.NetworkGroup,uLink.NetworkGroup)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkGroup" /> is less than the right <see cref="T:uLink.NetworkGroup" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkGroup.GetHashCode">
      <summary>
            Returns the hash code for this <see cref="T:uLink.NetworkGroup" />.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this <see cref="T:uLink.NetworkGroup" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkGroup.Equals(System.Object)">
      <summary>
            Indicates whether this <see cref="T:uLink.NetworkViewID" /> and a specified object are equal.
            </summary>
      <returns>
        <c>true</c> if <paramref name="other" /> and this <see cref="T:uLink.NetworkGroup" /> are the same type and represent the same value; otherwise, <c>false</c>.
            </returns>
      <param name="other">Another object to compare to. </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkGroup.CompareTo(uLink.NetworkGroup)">
      <summary>
            Compares this instance with another specified <see cref="T:uLink.NetworkGroup" /> object and indicates
            whether this instance precedes, follows, or appears in the same position
            in the sort order as the specified <see cref="T:uLink.NetworkGroup" />.
            </summary>
      <param name="other">The other <see cref="T:uLink.NetworkGroup" />.</param>
      <returns>
            A 32-bit signed integer that indicates whether this instance precedes, follows,
            or appears in the same position in the sort order as the value parameter.
            </returns>
    </member>
    <member name="M:uLink.NetworkGroup.ToString">
      <summary>
            Returns a formatted string with details on this <see cref="T:uLink.NetworkGroup" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:uLink.NetworkGroup.id">
      <summary>
            This is the unique ID number for this network group.
            </summary>
    </member>
    <member name="T:uLink.BitStream">
      <summary>
            Represents serialized variables, packed into a stream.
            </summary>
      <remarks>
            Data can be serialized, transmitted, and then received by remote clients by
            using this class. Read about state synchronization and automatic serializations
            of data types in the uLink manual to get the big picture. The code for
            serializing and deserializing objects are usually placed in the callback method
            <see cref="!:uLink.Network.uLink_OnSerializeNetworkView" />.
            Check out the C# and javascript code examples for that callback method. 
            <para> 
            Also see the two other callbacks that are used to serialize and
            desierialize objects in some special situations: 
            <see cref="!:uLink.Network.uLink_OnSerializeNetworkViewOwner" />
            and <see cref="!:uLink.NetworkP2P.uLink_OnHandoverNetworkView" />.
            </para><para> 
            We recommend that C# code and javascript code (also called Unity script)
            uses the methods <see cref="M:uLink.BitStream.Read``1(System.Object[])" /> and 
            <see cref="M:uLink.BitStream.Write``1" />. Yes, it is possible to
            use generic types in javascript in Unity. It is not possible to use generic
            types in javascript outside Unity, this is a feature that has been added by
            Unity since v3.0 of the Editor. 
            </para><para>
            Arrays (only one-dimentional) are handled by uLink. Arrays are no problem for 
            methods like <see cref="M:uLink.BitStream.Read``1(System.Object[])" /> and 
            <see cref="M:uLink.BitStream.Write``1" /></para><para> If you are using an Unity version older than 3.0, or for some other
            reason can't use generics, you can use the <see cref="O:uLink.BitStream.ReadObject" /> and <see cref="O:uLink.BitStream.WriteObject" />
            methods.
            </para><para> There are several methods for reading and writing just one specific
            datatype. These can be used to gain some performance, but the code you have to
            write will usually be a bit longer and not as elegant. Two examples of these
            method pairs are 
            <see cref="M:uLink.BitStream.ReadInt16" />/<see cref="M:uLink.BitStream.WriteInt16(System.Int16)" /> and 
            <see cref="M:uLink.BitStream.ReadString" />/<see cref="M:uLink.BitStream.WriteString(System.String)" />. 
            </para><para> 
            Because uLink is backward compatible with the Unity built-in network the
            method <see cref="O:uLink.BitStream.Serialize" />
            is included in this class and can still be used. It supports a limited set of
            basic datatypes (the same as Unity built-in network). The new method <see cref="M:uLink.BitStream.Serialize``1" /> can be
            used to handle more data types (all data types supported by uLink), but we
            recommend that you use the generic read/write methods whenever possible. </para></remarks>
    </member>
    <member name="F:uLink.BitStream.isTypeSafe">
      <summary>
            Used to make this stream serialize the type of data types and check all
            data types when deserializing. 
            </summary>
      <remarks>Set this value to <c>true</c> if you want extra validations
            when reading incoming data. This is good for debugging and it is
            also good for detecting clients sending wrong data to a 
            server or vice versa. Be aware that the serialized data will become longer when
            the data types has to be stored.</remarks>
      <exception cref="T:System.Exception">If expected data type does not match the
            data type in the stream when reading it.</exception>
      <value>Default is <c>false</c></value>
    </member>
    <member name="M:uLink.BitStream.Read``1(System.Object[])">
      <summary>
            Deserializes different types of variables. Recommended for C# code and javascript code.
            </summary>
      <param name="codecOptions">Optional parameters forwared to the deserializer</param>
      <remarks>
            Use this kind of function when reading from the stream.
            <para>
            The supported data types are documented in the uLink manual in the serialization section.
            </para></remarks>
    </member>
    <member name="M:uLink.BitStream.Write``1(``0,System.Object[])">
      <summary>
            Serializes different types of variables. Recommended for C# code and javascript code.
            </summary>
      <param name="value">The actual data</param>
      <param name="codecOptions">Optional parameters forwared to the serializer</param>
      <remarks>           
            Use this kind of function when writing the stream and the data type is known at design time.
            <para>All supported data types, that uLink serializes automatically, are documented in the uLink 
            manual in the serialization section.
            </para></remarks>
    </member>
    <member name="M:uLink.BitStream.ReadObject(System.RuntimeTypeHandle,System.Object[])">
      <summary>
            Deserializes different types of variables. Recommended for Javascript code in Unity 2.6.
            </summary>
      <param name="typeHandle">The data type for this value that will be serialized</param>
      <param name="codecOptions">Optional parameters forwared to the deserializer</param>
      <remarks>
            Use this function when reading from the stream and the code is javascript in Unity 2.6.
            Use <see cref="M:uLink.BitStream.Read``1(System.Object[])" /> if you can use generics, the code will 
            be easier to debug and maintain.
            <para>
            The supported data types are documented in the uLink manual in the serialization section.
            </para></remarks>
    </member>
    <member name="M:uLink.BitStream.WriteObject(System.RuntimeTypeHandle,System.Object,System.Object[])">
      <summary>
            Serializes different types of variables. Recommended for Javascript code in Unity 2.6.
            </summary>
      <param name="typeHandle">The data type for the value that will be serialized</param>
      <param name="value">The actual data</param>
      <param name="codecOptions">Optional parameters forwared to the serializer</param>
      <remarks>
            Use this function when writing to the stream and the code is javascript in Unity 2.6..
            Use <see cref="M:uLink.BitStream.Write``1" /> if you can use generics, the code will 
            be easier to debug and maintain.
            <para>All supported data types are documented in the uLink manual in the serialization section.
            </para></remarks>
    </member>
    <member name="M:uLink.BitStream.Serialize``1(``0@,System.Object[])">
      <summary>
            Serializes if <see cref="P:uLink.BitStream.isWriting" />, otherwise deserializes.
            </summary>
      <param name="value">Be aware this function can only handle a
            reference to a value. It can not be used for getting or setting properties
            therefore.</param>
      <param name="codecOptions">Optional parameters forwared to the serializer/deserializer</param>
      <remarks>
        <para>The supported data types are documented in the uLink manual in the serialization section.
            </para>
      </remarks>
    </member>
    <member name="M:uLink.BitStream.Serialize(System.Boolean@,System.Object[])">
      <summary>
            Serializes if <see cref="P:uLink.BitStream.isWriting" />, otherwise deserializes. 
            </summary>
      <param name="value">Be aware this function can only handle a
            reference to a value. Therefore it can not be used for getting or setting 
            properties.</param>
      <param name="codecOptions">Optional parameters forwarded to the serializer/deserializer</param>
      <remarks>
            This method for serializiation is included in uLink only because uLink is backward 
            compatible with Unity bilt-in network. The recommended uLink alternative is 
            <see cref="M:uLink.BitStream.Read``1(System.Object[])" /> and <see cref="M:uLink.BitStream.Write``1" />. 
            </remarks>
    </member>
    <member name="M:uLink.BitStream.GetRemainingBytes">
      <summary>
            Returns the remaining bytes in a byte array. 
            </summary>
    </member>
    <member name="M:uLink.BitStream.ReadBitStream">
      <summary>
            Copies the remaining bytes in a newly instantiated BitStream. 
            </summary>
      <remarks>
            Keeps the value if isWriting and isTypeSafe of the original Bitstream.
            </remarks>
    </member>
    <member name="M:uLink.BitStream.ToString">
      <summary>
            Returns a <see cref="T:System.String" /> that shows a list of all bytes in the BitStream.
            </summary>
    </member>
    <member name="P:uLink.BitStream.isWriting">
      <summary>
            Gets a value indicating whether the BitStream is currently being written to.
            </summary>
    </member>
    <member name="P:uLink.BitStream.isReading">
      <summary>
            Gets a value indicating whether the BitStream is currently being read.
            </summary>
    </member>
    <member name="P:uLink.BitStream.isEOF">
      <summary>
            Gets a value indicating whether there are any more bits to be read in the BitStream.
            </summary>
    </member>
    <member name="T:uLink.NetworkException">
      <summary>
            Thrown by uLink in error situations.
            </summary>
    </member>
    <member name="T:uLink.RPCReceiver">
      <summary>
            Read about this enum in <see cref="F:uLink.NetworkView.rpcReceiver" />.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.Off">
      <summary>
            Does not listen for incoming RPCs to this networkView, RPCs will be ignored.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.OnlyObservedComponent">
      <summary>
            Forwards incoming RPCs only to the observed component property, if it is a MonoBehaviour.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.ThisGameObject">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in this gameobject. Default value.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.ThisGameObjectAndChildren">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in this gameobject and also to all 
            MonoBehaviours in all of this gameobject's children.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.RootGameObjectAndChildren">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in the root gameobject, which this
            gameobject belongs to, and also to all MonoBehaviours in all the root's children.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.AllActiveGameObjects">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in all game objects activated in the scene.
            </summary>
    </member>
    <member name="F:uLink.RPCReceiver.GameObjects">
      <summary>
            Forwards incoming RPCs to all MonoBehaviours in the game objects specified by the rpcReceiverGameObjects property.
            </summary>
    </member>
    <member name="T:uLink.NetworkView">
      <summary>
            Very important class in uLink, contains implementation for the uLinkNetworkView script.
            </summary>
      <remarks>
            By adding the script uLinkNetworkView as a component in your GameObject
            or a prefab in Unity it is ready to be used for sending and receiving
            statesyncs and RPCs. The networkView is every network aware object's 
            only way to get data from the network and send data over the network.
            That is why you will find methods like 
            <see cref="O:uLink.NetworkView.RPC" /> and 
            <see cref="O:uLink.NetworkView.UnreliableRPC" /> 
            here.</remarks>
      <example>
            The common ways of interacting with the NetworkView instance for network aware objects
            in C# is writing classes 
            that extends <see cref="T:uLink.MonoBehaviour" /> and then accessing the networkView
            property available in all subclasses to <see cref="T:uLink.MonoBehaviour" />.
            <code>
            public class Example : uLink.MonoBehaviour {
            
            private int myID = networkView.viewID.id; 
            
            }
            </code>
            The common way of interacting with the NetworkView in a javascript is writing
            scripts that retrieves the networkView like in the code below. 
            <code>
            
            private var networkView = uLink.NetworkView.Get(this);
            private var myID = networkView.viewID.id;
            
            </code>    
            
            For this code to work, remember to add the 
            script you write as a script component to the prefab/GameObject.
            </example>
    </member>
    <member name="T:uLink.NetworkViewBase">
      <summary>
            Abstract base class for the class <see cref="T:uLink.NetworkView" />.
            </summary>
    </member>
    <member name="T:uLink.MonoBehaviour">
      <summary>
            Baseclass to inherit from when you do C# scripts that need to access
            the neworkView for a GameObject. 
            </summary>
      <remarks>It is very convenient to write C# scripts that have access to the property with
            the name networkView. To use this functionality, make your script class extend 
            uLink.MonoBehavior instead of using the MonoBehaviour included in Unity. In addition,
            the two properties networkP2P and role will be accessible.</remarks>
    </member>
    <member name="P:uLink.MonoBehaviour.transform">
      <summary>
            Gets the transform fast without a lookup.
            </summary>
    </member>
    <member name="P:uLink.MonoBehaviour.networkView">
      <summary>
            Gets the network view for this GameObject.
            </summary>
    </member>
    <member name="P:uLink.MonoBehaviour.networkP2P">
      <summary>
            Gets the networkP2P for this GameObject.
            </summary>
    </member>
    <member name="P:uLink.MonoBehaviour.role">
      <summary>
            Gets the role this peer/host has for this GameObject.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewBase.proxyPrefab">
      <summary>
            The prefab name used to find the proxy prefab.
            </summary>
      <remarks>
            This is only used during handover.
            <see cref="O:uLink.Network.Instantiate" /> automatically assigns this value during instantiation, so you don't have to worry about it.
            But if you have instantiated the object yourself and want to be able to handover it you will have to set this to the prefab name which uLink can use to find the proxy prefab.
            </remarks>
    </member>
    <member name="F:uLink.NetworkViewBase.ownerPrefab">
      <summary>
            The prefab name used to find the owner prefab.
            </summary>
      <remarks>
            This is only used during handover.
            <see cref="O:uLink.Network.Instantiate" /> automatically assigns this value during instantiation, so you don't have to worry about it.
            But if you have instantiated the object yourself and want to be able to handover it you will have to set this to the prefab name which uLink can use to find the owner prefab.
            </remarks>
    </member>
    <member name="F:uLink.NetworkViewBase.serverPrefab">
      <summary>
            The prefab name used to find the server prefab.
            </summary>
      <remarks>
            This is only used during handover.
            <see cref="O:uLink.Network.Instantiate" /> automatically assigns this value during instantiation, so you don't have to worry about it.
            But if you have instantiated the object yourself and want to be able to handover it you will have to set this to the prefab name which uLink can use to find the authority prefab.
            </remarks>
    </member>
    <member name="F:uLink.NetworkViewBase.stateSynchronization">
      <summary>
            The kind of state synchronization used for this object.
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkStateSynchronization.Unreliable" />.</value>
      <remarks>Read more in the uLink manual under the State Synchronization section. 
            The <see cref="P:uLink.Network.sendRate" /> can be used to configure the sending frequency 
            for state synchronization.</remarks>
    </member>
    <member name="F:uLink.NetworkViewBase.securable">
      <summary>
            Specifies the possibility to encrypt RPC traffic or statesync traffic or both.
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkSecurable.Both" />.</value>
    </member>
    <member name="M:uLink.NetworkViewBase.SetManualViewID(System.Int32)">
      <summary>
            Assigns the manual view ID for a GameObject.
            </summary>
      <remarks>This method can be used if the game programmer did not set the manualViewID for a 
            Game Object. The normal situation is that the game programmer places a GameObject in the Unity 
            editor's hierarchy view. After that, the programmer adds the component uLinkNetworkView and assigns 
            a manual view ID for that component. The programmers chooses a unique number like 1, 2, 3, etc.
            The maximum number is dictated by <see cref="P:uLink.Network.maxManualViewIDs" />.
            This function performs exactly the same thing, it makes it possible to write a script that sets 
            the manual view IDs for many GameObjects in a scene. 
            In addition: Several overloaded versions of the method <see cref="O:uLink.Network.Instantiate" />
            do the assignement of view IDs automatically. uLink uses viewIDs above the limit 
            <see cref="P:uLink.Network.maxManualViewIDs" /> for these automatic assignments. In some special situations 
            it can be handy to allocate a manual viewID first and then send this viewID as one of the arguments to 
            the uLink.Network.Instantiate method that accepts a viewID as one of the arguments.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetInitialData(System.Object[])">
      <summary>
            Sets the initial data for this network aware object.
            </summary>
      <remarks>Only use this function if you are working with custom allocation of viewIDs and needs to set
            the initial data for a network aware object. Normally, the initial data can be specified in the call to 
            one of the 
            <see cref="O:uLink.Network.Instantiate" /> 
            functions. Never use this function unless 
            you know what you are doing and you are working with custom allocation of viewIDs at runtime 
            (<see cref="O:uLink.Network.AllocateViewID" />).
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkPlayer)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The viewID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="owner">Will become the owner of this object</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkPlayer,uLink.NetworkGroup)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The viewID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="owner">Will become the owner of this object</param>
      <param name="group">Will become the group of this object. Default value is unassigned.</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkMessageInfo)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The view ID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="info">The sender of <see cref="T:uLink.NetworkMessageInfo" />
            will become the owner and the creator for this object</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
      <example>
            Can be used when instantiating NPCs in an MMO game.
            This method is usually called in all clients after receiving the viewID from the server via some 
            RPC call. Then the clients will become aware that the server has the owner and creater role for 
            this NPC Game Object.
            </example>
    </member>
    <member name="M:uLink.NetworkViewBase.SetViewID(uLink.NetworkViewID,uLink.NetworkMessageInfo,uLink.NetworkGroup)">
      <summary>
            Assigns the specified viewID to this NetworkView.
            </summary>
      <param name="viewID">The view ID you have created via a call to <see cref="O:uLink.Network.AllocateViewID" /></param>
      <param name="info">The sender of <see cref="T:uLink.NetworkMessageInfo" />
            will become the owner and the creator for this object</param>
      <param name="group">The group which this NetworkView will belong to</param>
      <remarks>
            Before calling this method, use <see cref="O:uLink.Network.AllocateViewID" /> to get a new allocated and thus 
            usable viewID. Use this method on the server and on all clients 
            to make them all treat this viewID in the same way.
            </remarks>
      <example>
            Can be used when instantiating NPCs in an MMO game.
            This method is usually called in all clients after receiving the viewID from the server via some 
            RPC call. Then the clients will become aware that the server has the owner and creater role for 
            this NPC Game Object.
            </example>
    </member>
    <member name="M:uLink.NetworkViewBase.SetUnassignedViewID">
      <summary>
            Removes the assigned viewID from this NetworkView.
            </summary>
      <remarks>
            Be aware that the viewID is still allocated. The next logical next is usually a call to <see cref="M:uLink.Network.DeallocateViewID(uLink.NetworkViewID)" />.
            </remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.AllocateViewID">
      <summary>
            Allocates one free viewID and sets it to this NetworkView. 
            </summary>
      <remarks>
            Only for advanced users. Works like <see cref="O:uLink.Network.AllocateViewID" />, but 
            in addition it sets the viewID to this NetworkView and the owner and 
            creator will become this <see cref="T:uLink.NetworkPlayer" />.
            <para>
            Can only be called in an authoritatve server or in authoritatve clients.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkViewBase.DeallocateViewID">
      <summary>
            Returns an unused viewID to the pool of unused IDs. Can only be called on the same peer as the viewID was allocated.
            </summary>
      <remarks>
            Works like <see cref="M:uLink.Network.DeallocateViewID(uLink.NetworkViewID)" /><para>
            Can only be called in an authoritatve server or in authoritatve clients.
            </para></remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.owner">
      <summary>
            Gets the owner for this network aware object.
            </summary>
      <remarks>Read more in the uLink manual about the three roles for network aware objects.</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.isMine">
      <summary>
            Gets a value indicating whether this instance is mine (and then I have the owner role).
            </summary>
      <value>
        <c>true</c> if this instance is mine; otherwise, <c>false</c>.</value>
      <remarks>Read more in the uLink manual about the three roles for objects created 
            with <see cref="O:uLink.Network.Instantiate" />.</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.isOwner">
      <summary>
            Gets a value indicating whether the current NetworkPlayer is the owner this object. Same as <see cref="P:uLink.NetworkViewBase.isMine" />.
            </summary>
      <value>
        <c>true</c> if this instance is mine; otherwise, <c>false</c>.</value>
      <remarks>Read more in the uLink manual about the three roles for objects created 
            with <see cref="O:uLink.Network.Instantiate" />.</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.authority">
      <summary>
            Gets the authoritative player over this object.
            </summary>
      <value>
        <see cref="F:uLink.NetworkPlayer.server" /> if authoritative server is enabled; otherwise, same as <see cref="P:uLink.NetworkViewBase.owner" />.</value>
      <remarks>Read more in the uLink manual about the three roles for network aware objects.</remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.hasAuthority">
      <summary>
            Gets a value indicating whether this instance of the network aware object has authority.
            </summary>
      <value>
        <c>true</c> if authoritative server is enabled and the instance is on the server; otherwise, same as <see cref="P:uLink.NetworkViewBase.isOwner" />.</value>
    </member>
    <member name="P:uLink.NetworkViewBase.localPrefab">
      <summary>
            Gets a prefab used to instantiate this local object.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.initialData">
      <summary> 
            Gets or sets the <see cref="T:uLink.BitStream" /> for initial data for
            this network aware object.
            </summary>
      <remarks>The initial data can be specified in the call to one of the
            <see cref="O:uLink.Network.Instantiate" /> methods. 
            After that, the initialData can be retrieved via this
            property. Never set this property manually unless you know what you
            are doing and you are working with custom allocation of viewIDs at
            runtime (<see cref="O:uLink.Network.AllocateViewID" />). 
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.childIndex">
      <summary> 
            Gets the child index for this NetworkView. (When mulitple NetworkViews per game object is used)
            </summary>
      <remarks>
            Avoid using mulitple NetworkViews for game objects instantiated with <see cref="O:uLink.Network.Instantiate" />.
            Read more about mulitple NetworkViews in the Network Views manual chapter.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.viewID">
      <summary>
            Gets the view ID for this network aware object.
            </summary>
      <remarks>
            The set-property is obsolete, use <see cref="O:uLink.NetworkViewBase.SetViewID" /> or <see cref="M:uLink.NetworkViewBase.SetManualViewID(System.Int32)" /> instead.
            This is only for backward compatibility with Unity's built-in networking. The owner and creator will be set to NetworkPlayer.server which may not be desired.
            </remarks>
    </member>
    <member name="P:uLink.NetworkViewBase.group">
      <summary>
            The RPC communication group used by this NetworkView.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.position">
      <summary>
            Gets the position for this Network View.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewBase.rotation">
      <summary>
            Gets the rotation for this Network View.
            </summary>
    </member>
    <member name="F:uLink.NetworkView.observed">
      <summary>
            The Component that this networkView should serialize when statesync is beeing sent or is received.
            </summary>
      <remarks>
            Note that <see cref="F:uLink.NetworkView.rpcReceiver" /> can be 
            set to <see cref="T:uLink.RPCReceiver">RPCReceiver.OnlyObservedComponent</see>. 
            In that case this field also dictates the rpcReceiver for this NetworkView.
            <para>
            Read more about the Component class in the Unity documentation.
            </para></remarks>
    </member>
    <member name="F:uLink.NetworkView.rpcReceiver">
      <summary>
            Gets or sets the receivers for incoming RPCs to this network view.
            </summary>
      <value>Default is <see cref="F:uLink.RPCReceiver.ThisGameObject" /></value>
      <remarks>All scripts attached to the same prefab/GameObject as this
            NetworkView will be able to get this RPC and can therefore contain
            code for RPC receiving. If you want to put RPC receiving code in
            scripts attached to a root gameobject or scripts attached to a child
            game object, this can be done, but this property needs to be changed
            then.</remarks>
    </member>
    <member name="M:uLink.NetworkView.ClearCachedRPCs">
      <summary>
            Advanced usage only: To increase performance uLink makes a cache of RPC receivers. The cache is populated 
            the first time an RPC is received. All RPC after the first call will be delivered to the same
            RPC receiver (a script component). The cache can be cleared by this method.
            </summary>
    </member>
    <member name="M:uLink.NetworkView.SetScope(uLink.NetworkPlayer,System.Boolean)">
      <summary>
            Set the scope of the network view in relation to a specific network player.
            This can be used to turn StateSync updates and RPCs temporarily on and off for a specific player, to reduce the 
            network traffic and thus bandwidth demands on the server and player. 
            </summary>
      <remarks>This can be used to implement relevant sets. If a player can't see an network view object, then relevancy can be turned off for that player. When the player (or 
            the object) later moves and is able to see the object, the relevancy must be turned on again. Read more in the 
            uLink manual about distance culling and occlusion culling.
            </remarks>
      <param name="target">The player affected by this scope change.</param>
      <param name="relevancy">Set to true or false depending on if you want the player to receive StateSync updates and RPCs from the network view or not.</param>
      <returns>The previous relevancy for the specific player.</returns>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])">
      <summary>
             Sends an RPC. Receivers are dictated by <see cref="T:uLink.RPCMode" />.
             </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
             this RPC should be buffered is also dictated by the 
             <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
             to the RPC method there (as argument).</param>
      <remarks>
             The called method must have the @RPC tag set ([RPC] for C Sharp
             code). A NetworkView must be attached to the GameObject where the
             RPC method is being called. It doesn't matter if the NetworkView
             is being used for something else or just for the RPC method. If it
             is just for the RPC method, state synchronization should be turned
             off and the observed property can be set to none. RPC method names
             should be unique across the scene, if two RPC methods in
             different scripts have the same name only one of them is called when
             RPC is invoked. RPC calls are always guaranteed to be executed in
             the same order as they are sent. The communication group set for the
             network view, with NetworkView.group, is used for the RPC call. To
             get information on the RPC itelf, you can add a <see cref="T:uLink.NetworkMessageInfo" />
             parameter to the receiving method's declaration, which will automatically
             contain the information. You don't need to change the way you call
             the RPC method when you do this. For more information see the RPC
             section of the uLink manual. 
             </remarks>
      <example>
             Javascript example code:
             <code>
             var cubePrefab : Transform;
             function OnGUI ()
             {
                if (GUILayout.Button("SendMessage"))
                {
                   networkView.RPC("TransferStrings",
                   RPCMode.All, "uLink ", "makes ", "me " "happy.");
                }
             }
            
             @RPC
             function TransferStrings (s1 : String, s2: String, s3: String, s4: String) {
                 Debug.Log("Got: " s1 + s2 + s3 + s4); 
             }
             </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" />.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
    </member>
    <member name="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC. Receivers are dictated by <see cref="T:uLink.RPCMode" />.
            </summary>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to specify optional <see cref="T:uLink.NetworkFlags" />
            . By setting the flags you have the power to control the handling of
            this RPC in uLink. Primarily you should use 
            <see cref="O:uLink.NetworkView.RPC" /> or 
            <see cref="O:uLink.NetworkView.UnreliableRPC" /> or 
            <see cref="O:uLink.NetworkView.UnencryptedRPC" /> (without NetworkFlags parameter). But
            sometimes those three methods are not enough,  then it is OK to
            use this method. Note that the buffer flag will override the buffer setting you can control
            via the <see cref="T:uLink.RPCMode" /> argument.
            </remarks>
      <example>
            If you want to send an RPC that is encrypted AND unreliable you can
            do that. Or if you want to send an RPC that has no timestamp, to
            save bandwidth, it is possible by setting the correct flag.
            </example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(uLink.NetworkFlags,System.String,uLink.RPCMode,``0)">
      <summary>
            Sends an RPC. Receivers are dictated by <see cref="T:uLink.RPCMode" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" />.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(uLink.NetworkFlags,System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkView.UnreliableRPC(System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC over a unreliable channel.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>Works exactly like <see cref="O:uLink.NetworkView.RPC" />, except that it is sent over an unreliable channel in uLink. This saves resources on the server and the client because there is no need to handle resends in uLink.
            </remarks>
    </member>
    <member name="M:uLink.NetworkView.UnreliableRPC``1(System.String,uLink.RPCMode,``0)">
      <summary>
            Sends an RPC over a unreliable channel.
            </summary>
    </member>
    <member name="M:uLink.NetworkView.UnreliableRPC(System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" /> over an unreliable channel.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>Works exactly like <see cref="O:uLink.NetworkView.RPC" />, except that it is sent over an unreliable channel in uLink. This saves resources on the server and the client because there is no need to handle resends in uLink.
            </remarks>
    </member>
    <member name="M:uLink.NetworkView.UnreliableRPC``1(System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends an RPC to the specified <see cref="T:uLink.NetworkPlayer" /> over an unreliable channel.
            </summary>
    </member>
    <member name="M:uLink.NetworkView.UnencryptedRPC(System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC without encryption.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>This method makes it possible
            to send unencrypted RPCs even when security has been turned on.
            </remarks>
    </member>
    <member name="M:uLink.NetworkView.UnencryptedRPC``1(System.String,uLink.RPCMode,``0)">
      <summary>
            Sends an RPC without encryption.
            </summary>
    </member>
    <member name="M:uLink.NetworkView.UnencryptedRPC(System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC the specified <see cref="T:uLink.NetworkPlayer" /> without encryption.
            </summary>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>This method makes it possible
            to send unencrypted RPCs even when security has been turned on.
            </remarks>
    </member>
    <member name="M:uLink.NetworkView.UnencryptedRPC``1(System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends an RPC the specified <see cref="T:uLink.NetworkPlayer" /> without encryption.
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambigous which script should recieve the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the reciever to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(System.Type,System.String,uLink.RPCMode,``0)">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambigous which script should recieve the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the reciever to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(System.Type,System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambigous which script should recieve the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the reciever to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(System.Type,uLink.NetworkFlags,System.String,uLink.RPCMode,``0)">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script (parameter type should be the type of one of your scripts). 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambigous which script should recieve the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the reciever to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(System.Type,uLink.NetworkFlags,System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script. 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambigous which script should recieve the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the reciever to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,System.String,uLink.RPCMode,``0)">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script. 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambigous which script should recieve the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the reciever to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="mode">The receiver is dictated by this parameter. If
            this RPC should be buffered is also dictated by the 
            <see cref="T:uLink.RPCMode" />.</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script. 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambigous which script should recieve the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the reciever to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.RPCMode,``0)">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <param name="type">The only script class that will receive this RPC</param>
      <param name="rpcName">Name of the RPC.</param>
      <param name="flags">Use this to control exactly how uLink will
            handle this RPC.</param>
      <param name="target">The target can be any player or the <see cref="F:uLink.NetworkPlayer.server" /> (the server is a predefined NetworkPlayer)</param>
      <param name="args">The arguments that the remote receiver will send
            to the RPC method executed there (as argument).</param>
      <remarks>
            Use this RPC method to send an RPC to a specific script. 
            Use this method if there are two scripts including an RPC with the exact same name. When there are
            two scripts with an RPC with the exact same name, it is ambigous which script should recieve the RPC.
            By specifying the type, this ambiguity is avoided.
            </remarks>
      <example>
            These two code lines shows the two common ways of sending an RPC and restrict the reciever to only a specific type of script.
            <code>
            uLink.NetworkView.Get(this).RPC(typeof(MyEpicScript), "MyRPC", ...);
            uLink.NetworkView.Get(this).RPC(this, "MyRPC", ...);
            </code></example>
    </member>
    <member name="M:uLink.NetworkView.RPC``1(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.NetworkPlayer,``0)">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
    </member>
    <member name="M:uLink.NetworkView.RemoveRPCs">
      <summary>
            Removed all custom buffered RPCs for this network view.
            </summary>
      <remarks>If any buffered RPCs has been sent via this network view, they can be removed using this method.</remarks>
    </member>
    <member name="M:uLink.NetworkView.Find(uLink.NetworkViewID)">
      <summary>
            Returns the NetworkView instance that has the specified viewID.
            </summary>
      <returns>Returns a NetworkView instance or <c>null</c> if nothing was found</returns>
    </member>
    <member name="M:uLink.NetworkView.FindByOwner(uLink.NetworkPlayer)">
      <summary>
            Returns an array of NetworkView instances, that all have the specified owner.
            </summary>
      <returns>Returns an array of NetworkView instance. If nothing was found, the array length is 0. Never returns null.</returns>
    </member>
    <member name="M:uLink.NetworkView.FindInGroup(uLink.NetworkGroup)">
      <summary>
            Returns an array of NetworkView instances, that all belong to specified group.
            </summary>
      <returns>Returns an array of NetworkView instance. If nothing was found, the array length is 0. Never returns null.</returns>
    </member>
    <member name="M:uLink.NetworkView.Get(UnityEngine.GameObject)">
      <summary>
            Gets the NetworkView instance from the specified GameObject.
            </summary>
      <param name="gameObject">Read about the Game Object class in the Unity documentation.</param>
    </member>
    <member name="M:uLink.NetworkView.Get(UnityEngine.Component)">
      <summary>
            Gets the NetworkView instance from the specified Component.
            </summary>
      <param name="component">Read about the Component class in the Unity documentation.</param>
    </member>
    <member name="P:uLink.NetworkView.position">
      <summary>
            Gets the position of this network aware object.
            </summary>
    </member>
    <member name="P:uLink.NetworkView.rotation">
      <summary>
            Gets the rotation of this network aware object.
            </summary>
    </member>
    <member name="T:uLink.NetworkEmulation">
      <summary>
            Emulates network problems like lost packets, duplicate packets and latency 
            fluctuations. See <see cref="P:uLink.Network.emulation" />. 
            </summary>
    </member>
    <member name="P:uLink.NetworkEmulation.maxBandwidth">
      <summary>
            Gets or sets the maximum emulated bandwidth when sending from this peer.
            </summary>
    </member>
    <member name="P:uLink.NetworkEmulation.chanceOfLoss">
      <summary>
            This is a float which simulates lost UDP packets when sending from this peer.
            </summary>
      <remarks>A value of 0 will disable this feature, 
            a value of 0.5 will make half of your sent packets disappear, chosen randomly. Note that 
            one UDP packet may contain several uLink messages (RPCs and statesyncs) - this is the amount 
            of UDP packets lost. 
            </remarks>
    </member>
    <member name="P:uLink.NetworkEmulation.chanceOfDuplicates">
      <summary>
            Dictates the chance that a packet will be duplicated at the destination, when sent from this peer. 
            </summary>
      <remarks>
            0 means no packets will be duplicated, 0.5 means that on average, every other packet will be duplicated. 
            </remarks>
    </member>
    <member name="P:uLink.NetworkEmulation.minLatency">
      <summary>
            Gets or sets the minimum emulated one-way latency addition for packets in seconds (not milliseconds)
            </summary>
      <remarks>
            This value and <see cref="P:uLink.NetworkEmulation.maxLatency" /> work on top of the actual network delay and the total delay will be: 
            Actual one way latency + <see cref="P:uLink.NetworkEmulation.minLatency" /> + (randomly per packet 0 to <see cref="P:uLink.NetworkEmulation.maxLatency" /> seconds) 
            when sending from this peer
            </remarks>
    </member>
    <member name="P:uLink.NetworkEmulation.maxLatency">
      <summary>
            Gets or sets the maximum emulated one-way latency addition for packets in seconds (not milliseconds)
            </summary>
      <remarks>
            This value and <see cref="P:uLink.NetworkEmulation.minLatency" /> work on top of the actual network delay and the total delay will be: 
            Actual one way latency + <see cref="P:uLink.NetworkEmulation.minLatency" /> + (randomly per packet 0 to <see cref="P:uLink.NetworkEmulation.maxLatency" /> seconds) 
            when sending from this peer
            </remarks>
    </member>
    <member name="T:uLink.HostData">
      <summary>
            Data structure for holding individual host (server) information.
            </summary>
      <remarks>
            The host list retrieved from a master server uses this class to represent individual servers. 
            See <see cref="M:uLink.MasterServer.PollHostList" /></remarks>
    </member>
    <member name="F:uLink.HostData.externalEndpoint">
      <summary>
            The public IP address and port for this host on the Internet. 
            </summary>
    </member>
    <member name="F:uLink.HostData.ping">
      <summary>
            Returns the round trip ping time in milliseconds from the master server to the 
            game server, or if this is a WellKnownHost the ping time is instead meassured 
            between the client and the host.
            </summary>
      <remarks>
            The most usable ping time is for WellKnownHosts since it is meassured between 
            the client and the game server(s). A player is usually looking for a nearby server 
            with a nice low ping time. 
            <para>
            The ping time between the master server and the game server can be useful in some situations.
            How useful it is depends on where servers are hosted. uLink provides this value to be used in 
            any way you want.</para><para>
            If the host needs a proxy this ping time is 
            not correct. Do not use this ping time in the proxy case.  
            </para><para>
            Pingtime between a server and connected players is available via <see cref="M:uLink.Network.GetAveragePing(uLink.NetworkPlayer)" /></para></remarks>
    </member>
    <member name="P:uLink.HostData.externalPort">
      <summary>
            Server public port, used by clients on the Internet to connect to the server.
            </summary>
    </member>
    <member name="P:uLink.HostData.externalIP">
      <summary>
            Server public IP address, used by clients on the Internet to connect to the server.
            </summary>
    </member>
    <member name="P:uLink.HostData.port">
      <summary>
            Server public port, used by clients on the Internet to connect to the server. Same as <see cref="P:uLink.HostData.externalPort" />.
            </summary>
    </member>
    <member name="P:uLink.HostData.ipAddress">
      <summary>
            Server public IP address, used by clients on the Internet to connect to the server. Same as <see cref="P:uLink.HostData.externalIP" />.
            </summary>
    </member>
    <member name="P:uLink.HostData.ip">
      <summary>
            Server IP address
            </summary>
    </member>
    <member name="P:uLink.HostData.guid">
      <summary>
            Use HostData.externalEndpoint.ToString() instead
            </summary>
    </member>
    <member name="T:uLink.BitStreamCodec">
      <summary>
            Used to build custom handling for serializing and deserializing of your game objects.
            </summary>
      <remarks>
            It is possible to build custom serialization and deserialization for any data type. Replace the uLink default 
            serializer and deserializer for any data type, or make a new data type and register it in uLink.
            </remarks>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeNullableAndArray``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Add codec for specified type, including support for null values and arrays
            </summary>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeNullableAndArray``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Add codec for specified type, including support for null values and arrays
            </summary>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeNullable``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Add codec for specified type, including support for null values
            </summary>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeNullable``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Add codec for specified type, including support for null values
            </summary>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeArray``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Add codec for specified type, including support for arrays.
            </summary>
    </member>
    <member name="M:uLink.BitStreamCodec.AddAndMakeArray``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Add codec for specified type, including support for arrays.
            </summary>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.Add``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Adds a serialization codec for the specified user-defined type.
            </summary>
      <parameter name="T">The type that should be serialized using this codec.</parameter>
      <parameter name="deserializer">The deserializer function. Based on the uLink.BitStreamCodec.Deserializer delegate.</parameter>
      <parameter name="serializer">The serializer function. Based on the uLink.BitStreamCodec.Serializer delegate.</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.Add``1(uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Adds a serialization codec for the specified user-defined type.
            </summary>
      <parameter name="T">The type that should be serialized using this codec.</parameter>
      <parameter name="deserializer">The deserializer function. Based on the uLink.BitStreamCodec.Deserializer delegate.</parameter>
      <parameter name="serializer">The serializer function. Based on the uLink.BitStreamCodec.Serializer delegate.</parameter>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.Add(System.RuntimeTypeHandle,uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer)">
      <summary>
            Add codec for specified type
            </summary>
    </member>
    <member name="M:uLink.BitStreamCodec.Add(System.RuntimeTypeHandle,uLink.BitStreamCodec.Deserializer,uLink.BitStreamCodec.Serializer,uLink.BitStreamTypeCode,System.Boolean)">
      <summary>
            Add codec for specified type
            </summary>
      <parameter name="typeCode">Type code, used to provide type-safe serialization as described in the "Serialization and data types" chapter in the manual</parameter>
    </member>
    <member name="M:uLink.BitStreamCodec.Remove(System.RuntimeTypeHandle)">
      <summary>
            Removes codec for specified type
            </summary>
    </member>
    <member name="T:uLink.BitStreamCodec.Deserializer">
      <summary>
            Signature for deserializing (reader) methods
            </summary>
    </member>
    <member name="T:uLink.BitStreamCodec.Serializer">
      <summary>
            Signature for serializing (writer) methods
            </summary>
    </member>
    <member name="T:uLink.NetworkPeer">
      <summary>
            Represents one peer/host i a peer-to-peer network.
            </summary>
    </member>
    <member name="T:uLink.NetworkStatistics">
      <summary>
            Read live network statistics for one <see cref="T:uLink.NetworkPlayer" />. Available via <see cref="P:uLink.NetworkPlayer.statistics" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.bytesSentPerSecond">
      <summary>
            Gets bytesSentPerSecond.
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.bytesReceivedPerSecond">
      <summary>
            Gets bytesReceivedPerSecond
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.userBytesSentPerSecond">
      <summary>
            Gets userBytesSentPerSecond
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.userBytesReceivedPerSecond">
      <summary>
            Gets userBytesReceivedPerSecond
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.bytesSent">
      <summary>
            Gets bytesSent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.bytesReceived">
      <summary>
            Gets bytesReceived
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.userBytesSent">
      <summary>
            Gets userBytesSent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.userBytesReceived">
      <summary>
            Gets userBytesReceived 
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.packetsSent">
      <summary>
            Gets packetsSent 
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.packetsReceived">
      <summary>
            Gets packetsReceived 
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesSent">
      <summary>
            Gets messagesSent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesReceived">
      <summary>
            Gets messagesReceived
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesResent">
      <summary>
            Gets messagesResent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesStored">
      <summary>
            Gets messagesStored
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesUnsent">
      <summary>
            Gets messagesUnsent
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messagesWithheld">
      <summary>
            Gets messagesWithheld
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messageDuplicatesRejected">
      <summary>
            Gets messageDuplicatesRejected
            </summary>
    </member>
    <member name="P:uLink.NetworkStatistics.messageSequencesRejected">
      <summary>
            Gets messageSequencesRejected
            </summary>
    </member>
    <member name="T:uLink.NetworkInstantiator">
      <summary>
            A registry for instatiators for prefabs. 
            </summary>
      <remarks>
            Most common usage of this class is to use the methods <see cref="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject)" />
            to register prefabs downloaded in an asset bundle before they can be instantiated by calling
            <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>.
            <para>
            The methods here are also used by the utility script uLinkInstantiatePool.cs to make
            it possible to configure a pool of network-instatiated game objects without having to change 
            any code at all.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.AddAssetBundle(UnityEngine.AssetBundle)">
      <summary>
            Registers all prefabs in the asset bundle that does have a networkview component.   
            This makes sure they can be instantiated later with 
            <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see></summary>
      <remarks>
            This is a convenience method that calls <see cref="O:uLink.NetworkInstantiator.AddPrefab" />
            for all prefabs in the asset bundle that has a network view component.
            <para>
            It is common for developers to minimize the download time for the Unity game at startup by putting
            some prefabs in assert bundles and then download the asset bundles when needed in the game. 
            We recommend writing code that downloads the asset bundle, loads the prefabs, registers them with this method, 
            and finally makes the calls to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>. 
            If it is an authoritative server the call to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            has to be done on the server.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject)">
      <summary>
            Registers a prefab to make sure it can be instantiated 
            later with <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            by creating and adding a default instantiator for the specified gameobject. 
            </summary>
      <remarks>
            With this uLink feature it is possible to registering prefabs 
            that are located anywhere in the project. 
            The old uLink restriction that all prefabs must reside in the Resource folder is overruled.
            Place the prefab in any folder in the project, but remember to call this method on all 
            clients and the server before calling <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>.
            <para>
            When the server is authoritative, registration on the clients usually includes the prefab for 
            proxies and the owner. Registration on the server includes only the prefab for the creator.
            </para><para>
            There is also a convenient utility script called uLinkRegisterPrefabs that calls this method for you.
            Read more about that script in the uLink manual chapter for instantiating objects.
            </para><para>
            It is common for developers to minimize the download time for the Unity game at startup by putting
            some prefabs in assert bundles and then download the asset bundles when needed in the game. 
            We recommend writing code that downloads the asset bundle, loads the prefabs, registers them with 
            <see cref="O:uLink.NetworkInstantiator.AddAssetBundle" />, 
            and finally makes the calls to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>.
            If it is an authoritative server the call to <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            has to be done on the server.
            </para></remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject,System.Boolean)">
      <summary>
            Registers a prefab to make sure it can be instantiated 
            later with <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>
            by creating and adding a default instantiator for the specified gameobject.  
            Read remarks <see cref="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject)">here</see></summary>
    </member>
    <member name="M:uLink.NetworkInstantiator.Remove(System.String)">
      <summary>
            Removes a instantiator. If this instantiator was added by <see cref="M:uLink.NetworkInstantiator.AddPrefab(UnityEngine.GameObject)" />
            and the specific gameobject is not placed in a Resources-folder then that gameobject can no longer be used
            with <see cref="O:uLink.Network.Instantiate">uLink.Network.Instantiate</see>.
            </summary>
      <remarks>
            It is nice to be able to remove all references to a prefab to make it possible 
            to unload it and reduce memory footprint in the Unity player. This can for example
            be used in a web player when switching from one scene to another or when switching from 
            one game mode to another. Read more in the Unity manual about garbage collection and 
            unloading prefabs. 
            </remarks>
    </member>
    <member name="M:uLink.NetworkInstantiator.RemoveAll">
      <summary>
            Removes all instantiators. See also <see cref="M:uLink.NetworkInstantiator.Remove(System.String)" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkInstantiator.Find(System.String)">
      <summary>
            Used internally by uLink when executing Network.Instantiate, but it is also public to make it easier to debug problems with NetworkInstantiator.
            </summary>
    </member>
    <member name="T:uLink.NetworkInstantiator.Creator">
      <summary>
            Signature for creator methods
            </summary>
    </member>
    <member name="T:uLink.NetworkInstantiator.Destroyer">
      <summary>
            Signature for destroyer methods
            </summary>
    </member>
    <member name="T:uLink.Network">
      <summary>
            The central class in uLink. Contains core functionality in uLink.
            </summary>
      <remarks>
            This class enables several core uLink features such as: starting servers,
            connecting clients, dynamically instantiating network aware objects and
            security/encryption features. Functions marked as "Message callbacks"
            are callbacks sent from uLink, which can be implemented in your scripts to
            handle network events with custom code in a client or a server.
            </remarks>
    </member>
    <member name="M:uLink.Network.AllocateViewID">
      <summary>
            Query for the next available network view ID number and allocate it.
            </summary>
      <remarks>
            Only use this function if you are an advanced user and know what you are doing. For
            mall common situations in a multiplayer game you should be fine using 
            <see cref="O:uLink.Network.Instantiate" /> 
            to instantiate network aware prefabs, or if it is a
            static game object in the hierarchy view of the scene, give it a manual view ID during development.
            If you choose to use this function, this viewID number can then be assigned to the 
            network view of an instantiated object (not instantiated via the Network class).
            <para>
            This method can only be called in an authoritatve server or in an authoritatve client.
            </para><para>
            The owner of this viewID will become the local <see cref="T:uLink.NetworkPlayer" /></para><para>
            When running an authoritative server, the next logical step after calling this method on the server is to send an RPC to 
            <see cref="T:uLink.RPCMode">RPCMode.All</see> including the new viewID and in the RPC receiving code write a call to 
            <see cref="O:uLink.NetworkViewBase.SetViewID" />.
            This will make all connected peers aware of how to connect this new viewID to a 
            Game Object. It must be a Game Object that has an attached uLink NetworkView script component.
            </para><para>
            uLink never allocated the same viewID right after a call to <see cref="M:uLink.Network.DeallocateViewID(uLink.NetworkViewID)" />. 
            The reason for this is to avoid subtile bugs where a viewID is resued so fast that some connected peers might 
            miss this very important event (for example due to UDP packets arriving in the wrong order) and excecute 
            RPC code on the wrong game object. Therefore it is safe to make several fast calls to AllocateViewID 
            and DeallocateViewID right after each other.
            </para><para>
            ViewIDs are represented with a 16 bit number in uLink. This makes the maximum number of viewIDs 65536.
            </para></remarks>
      <example>
            The example below demonstrates a simple method to do this. Note that for this to 
            work there must be a uLinkNetworkView component attached to the object which has this script and 
            it must have the script as its observed property. There must be a Cube prefab present 
            also with a uLinkNetworkView component which watches something (like the Transform of the Cube). The 
            cubePrefab variable in the script must be set to that cube prefab. This is the simplest 
            method of using AllocateViewID. 
            <code>
            var cubePrefab : Transform;
            function OnGUI ()
            {
                if (GUILayout.Button("SpawnBox"))
                {
                    var viewID = uLink.Network.AllocateViewID();
                    uLink.NetworkView.Get(this).RPC("SpawnBox", uLink.RPCMode.AllBuffered, viewID, transform.position);    
                }
            }
            
            @RPC
            function SpawnBox (viewID : uLink.NetworkViewID, location : Vector3)
            {
                // Instantate the prefab locally
                var clone : Transform;
                clone = Instantiate(cubePrefab, location, Quaternion.identity);
                var nView : NetworkView;
                nView = clone.GetComponent(uLink.NetworkView);
                nView.viewID = viewID;
            }
            </code></example>
    </member>
    <member name="M:uLink.Network.AllocateViewID(uLink.NetworkPlayer)">
      <summary>
            Allocates one viewID and sets the owner at the same time.
            </summary>
      <remarks>
            Works just like <see cref="O:uLink.Network.AllocateViewID" />.
            </remarks>
    </member>
    <member name="M:uLink.Network.AllocateViewIDs(System.Int32)">
      <summary>
            Allocates an array of viewIDs at once.
            </summary>
      <remarks>
            Works just like <see cref="O:uLink.Network.AllocateViewID" />.
            <para>
            The owner of this array of viewIDs will become the local <see cref="T:uLink.NetworkPlayer" /></para></remarks>
    </member>
    <member name="M:uLink.Network.AllocateViewIDs(System.Int32,uLink.NetworkPlayer)">
      <summary>
            Allocates an array of viewIDs at once and sets the owner for all of them.
            </summary>
      <remarks>
            Works just like <see cref="O:uLink.Network.AllocateViewID" />.
            </remarks>
    </member>
    <member name="M:uLink.Network.DeallocateViewID(uLink.NetworkViewID)">
      <summary>
            Returns an unused viewID to the pool of unused IDs. 
            </summary>
      <remarks>
            Can only be called in an authoritatve server or in authoritatve clients. 
            Can only be called on the same peer as the viewID was allocated.
            </remarks>
    </member>
    <member name="M:uLink.Network.DeallocateViewIDs(uLink.NetworkViewID[])">
      <summary>
            Returns an array of viewIDs to the pool of unused IDs. 
            </summary>
      <remarks>
            Can only be called in an authoritatve server or in authoritatve clients. 
            Can only be called on the same peer as the viewIDs was allocated.
            </remarks>
    </member>
    <member name="M:uLink.Network.DeallocateViewIDs(uLink.NetworkPlayer)">
      <summary>
            Returns all viewIDs for one <see cref="T:uLink.NetworkPlayer" /> to the pool of unused IDs. 
            </summary>
      <remarks>
            Can only be called in an authoritatve server or in authoritatve clients. 
            Can only be called on the same peer as the viewIDs was allocated.
            </remarks>
    </member>
    <member name="M:uLink.Network.CloseConnection(uLink.NetworkPlayer,System.Boolean)">
      <summary>
            Close the connection to another system.
            </summary>
      <param name="target">Defines which system to close the connection to</param>
      <param name="sendDisconnectionNotification">if set to <c>true</c> sends a reliable disconnection notification to target.</param>
      <remarks>If we are a client the only possible connection to close is the server connection, 
            if we are a server the target player will be kicked out.  If sendDisconnectionNotification is 
            <c>false</c> the connection is dropped, if <c>true</c> a disconnect notification is reliably 
            sent to the remote peer and thereafter the connection is dropped.</remarks>
    </member>
    <member name="M:uLink.Network.CloseConnection(uLink.NetworkPlayer,System.Boolean,System.Int32)">
      <summary>
            Close the connection to another system.
            </summary>
      <param name="target">Defines which system to close the connection to</param>
      <param name="sendDisconnectionNotification">if set to <c>true</c> sends a reliable disconnection notification to target.</param>
      <param name="timeout">Will wait this long (seconds) for the ack of the uLink internal disconnect notification RPC before dropping the client anyway.</param>
    </member>
    <member name="M:uLink.Network.Connect(uLink.HostData)">
      <summary>Connects this client to the specified server, registerd in the master server.</summary>
      <param name="host">This is the <see cref="T:uLink.HostData" /> received from the <see cref="T:uLink.MasterServer" />.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(System.Net.IPEndPoint)">
      <summary>Connects this client to the specified server.</summary>
      <param name="server">The server (includes host and port)</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(System.String,System.Int32)">
      <summary>Connects this client to the specified server.</summary>
      <param name="host">Hostname as string or IP address as a String (four numbers with dots between)</param>
      <param name="remotePort">Server port number</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(System.String[],System.Int32)">
      <summary>Connects this client to the specified server.</summary>
      <param name="hosts">Try to connect to the servers in this array, one by one, until a 
            connections is established</param>
      <param name="remotePort">Server port number</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(uLink.HostData,System.String,System.Object[])">
      <summary>Connects this client to the specified server, registerd in the master server.</summary>
      <param name="host">This is the <see cref="T:uLink.HostData" /> received from the <see cref="T:uLink.MasterServer" />.</param>
      <param name="password">Sends a password (salted and hashed) inside this connection request. 
            Use this as a game/level/instance password if it suits the needs of the game.</param>
      <param name="loginData">Put any number of arguments here as loginData. The data will be 
            delivered to the server and the server can handle the data as a <see cref="T:uLink.BitStream" /> 
            in the notification <see cref="!:uLink.Network.uLink_OnPlayerApproval" />. The server can use this loginData  
            to make a choice between approving the client or denying the client. Use this feature for 
            things like Avatar name, preferred team membership, username, password, client type, etc. 
            It is possible and recommended to encrypt password and loginData. Set 
            <see cref="P:uLink.Network.publicKey" /> in
            the client to turn on encryption before calling this method.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(System.Net.IPEndPoint,System.String,System.Object[])">
      <summary>Connects this client to the specified server.</summary>
      <param name="server">The server (includes host and port)</param>
      <param name="password">Sends a password (salted and hashed) inside this connection request. 
            Use this as a game/level/instance password if it suits the needs of the game.</param>
      <param name="loginData">Put any number of arguments here as loginData. The data will be 
            delivered to the server and the server can handle the data as a <see cref="T:uLink.BitStream" /> 
            in the notification <see cref="!:uLink.Network.uLink_OnPlayerApproval" />. The server can use this loginData  
            to make a choice between approving the client or denying the client. Use this feature for 
            things like Avatar name, preferred team membership, username, password, client type, etc. 
            It is possible and recommended to encrypt password and loginData. Set 
            <see cref="P:uLink.Network.publicKey" /> in
            the client to turn on encryption before calling this method.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, <see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(System.String,System.Int32,System.String,System.Object[])">
      <summary>Connects this client to the specified server.</summary>
      <param name="host">Hostname as string or IP address as a String (four numbers with dots between)</param>
      <param name="remotePort">Server port number</param>
      <param name="password">Sends a password (salted and hashed) inside this connection request. 
            Use this as a game/level/instance password if it suits the needs of the game.</param>
      <param name="loginData">Put any number of arguments here as loginData. The data will be 
            delivered to the server and the server can handle the data as a <see cref="T:uLink.BitStream" /> 
            in the notification <see cref="!:uLink.Network.uLink_OnPlayerApproval" />. The server can use this loginData  
            to make a choice between approving the client or denying the client. Use this feature for 
            things like Avatar name, prefered team membership, username, password, client type, etc. 
            It is possible and recommended to encrypt password and loginData. Set 
            <see cref="P:uLink.Network.publicKey" /> in
            the client to turn on encryption before calling this method.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Connect(System.String[],System.Int32,System.String,System.Object[])">
      <summary>Connects this client to the specified server.</summary>
      <param name="hosts">Try to connect to the servers in this array, one by one, until a 
            connections is established</param>
      <param name="remotePort">Server port number</param>
      <param name="password">Sends a password (salted and hashed) inside this connection request. 
            Use this as a game/level/instance password if it suits the needs of the game.</param>
      <param name="loginData">Put any number of arguments here as loginData. The data will be 
            delivered to the server and the server can handle the data as a <see cref="T:uLink.BitStream" /> 
            in the notification <see cref="!:uLink.Network.uLink_OnPlayerApproval" />. The server can use this loginData  
            to make a choice between approving the client or denying the client. Use this feature for 
            things like Avatar name, prefered team membership, username, password, client type, etc. 
            It is possible and recommended to encrypt password and loginData. Set 
            <see cref="P:uLink.Network.publicKey" /> in
            the client to turn on encryption before calling this method.</param>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors, NetworkConnectionError.<see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.Destroy(uLink.NetworkView)">
      <summary>
             Destroy the game object associated with this <see cref="T:uLink.NetworkView" /> across the 
             network and remove the buffered RPCs for this <see cref="T:uLink.NetworkView" /> from the uLink RPC buffer.
            </summary>
      <remarks>The object is destroyed locally and remotely.</remarks>
    </member>
    <member name="M:uLink.Network.Destroy(uLink.NetworkViewID)">
      <summary>
             Destroy the game object associated with this <see cref="T:uLink.NetworkViewID" /> across the 
             network and remove the buffered RPCs for this <see cref="T:uLink.NetworkViewID" /> from the uLink RPC buffer.
            </summary>
      <remarks>The object is destroyed locally and remotely.</remarks>
    </member>
    <member name="M:uLink.Network.Destroy(UnityEngine.GameObject)">
      <summary>
             Destroy this game object across the network and remove the buffered RPCs 
             for the <see cref="T:uLink.NetworkViewID" /> attached to this gameObject from the uLink RPC buffer.
            </summary>
      <remarks>The object is destroyed locally and remotely.</remarks>
    </member>
    <member name="M:uLink.Network.DestroyPlayerObjects(uLink.NetworkPlayer)">
      <summary>
            Destroy all network aware objects owned by this player across the
            network and remove the buffered RPCs from the uLink RPC buffer.
            </summary>
      <remarks>
        <para>The objects owned by this player are destroyed locally and
            remotely. It is common to call this method in the callback 
            <see cref="!:uLink_OnPlayerDisconnected(uLink.NetworkPlayer)" />.
            </para>
        <para>
            All buffered RPCs (including the instantiating RPCs) for the objects 
            owned by this player are removed from the uLink RPC buffer. This is 
            done by internal calls to <see cref="M:uLink.Network.RemoveInstantiates(uLink.NetworkPlayer)" />
            and <see cref="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer)" />.
            </para>
        <para>
            Who owns a network instantiated object is determined when the 
            <see cref="O:uLink.Network.Instantiate" /> method is used. If the
            owner hasn't been specified in the arguments to Instantiate, it is
            the caller of Instantiate.
            </para>
      </remarks>
    </member>
    <member name="M:uLink.Network.DestroyAll">
      <summary>
            Destroy all network aware objects accross the network and remove all buffered RPCs from the uLink RPC buffer.
            </summary>
    </member>
    <member name="M:uLink.Network.Disconnect">
      <summary>
            Closes the network connection.
            </summary>
      <remarks>This disconnect function uses a default timeout value of 200 ms. If this is a client, it will send 
            a reliable disconnect message to the server and wait for the ack during the timeout. During the timeout, 
            incoming and outgoing statesync and RPCs will be handled as normal.
            
            The complete network state, like security and password, is reset by this function. 
            
            If this is a server, it will disconnect all clients after sending a disconnect messages to them.</remarks>
    </member>
    <member name="M:uLink.Network.Disconnect(System.Int32)">
      <summary>
            Closes the network connection.
            </summary>
      <param name="timeout">Indicates how long this network connection will wait for an ack message and during that wait time it will continue to receive RPCs and statesyncs.</param>
      <remarks>If this is a client, it will try to send 
            a disconnect message to the server before this timeout. During the timeout, incoming statesync and RPCs will be handled as normal.
            If the timeout passes and the ack has not been received, the client will disconnect and clean up anyway.
            
            The network state, like security and password, is reset by this function. 
            
            If this is a server, it will disconnect all clients after sending a disconnect messages to them.</remarks>
    </member>
    <member name="M:uLink.Network.DisconnectImmediate">
      <summary>
            Closes the network connection immediately without any notification to others.
            </summary>
      <remarks>The only way others will notice this is by a timeout. Read more about such timeouts 
            in the callback <see cref="!:uLink.Network.uLink_OnPlayerDisconnected" />.</remarks>
    </member>
    <member name="M:uLink.Network.GetAveragePing(uLink.NetworkPlayer)">
      <summary>
            Gets average ping time for a player in milliseconds.
            </summary>
      <returns>Average ping time for a player in milliseconds. If target is unknown or not connected, then returns -1</returns>
      <remarks>Calculates the average of the last few pings, making this a moving average.
            In the client you should call GetAveragePing(uLink.NetworkPlayer.server) because the only available target is the server. 
            In the server you can check the ping time to any connected player.
            </remarks>
    </member>
    <member name="M:uLink.Network.GetLastPing(uLink.NetworkPlayer)">
      <summary>
            Gets last ping time for a player in milliseconds.
            </summary>
      <returns>Last ping time for a player in milliseconds. If target is unknown or not connected, then returns -1</returns>
      <remarks>In the client you should call GetLastPing(uLink.NetworkPlayer.server) because the only available target is the server. 
            In the server you can check the ping time to any connected player.
            </remarks>
    </member>
    <member name="M:uLink.Network.GetStatistics(uLink.NetworkPlayer)">
      <summary>
            Gets a <see cref="T:uLink.NetworkStatistics" /> object for the specified remote player.
            </summary>
      <param name="target">The player at the other end of the connection that you want statistics for.</param>
      <returns>A <see cref="T:uLink.NetworkStatistics" /> object if there is a connection to the player, or null otherwise</returns>
    </member>
    <member name="M:uLink.Network.HavePublicAddress">
      <summary>
            Check if this machine has a public IP address.
            </summary>
      <remarks>
            It checks all the network interfaces for IPv4 public addresses and returns true if one address is found.
            </remarks>
    </member>
    <member name="M:uLink.Network.InitializeServer(System.Int32,System.Int32)">
      <summary>
            Initializes the server.
            </summary>
      <param name="maximumConnections">The maximum number of connections/players.</param>
      <param name="listenPort">The UDP listen port.</param>
      <example>
        <code>
            function LaunchServer () {
               uLink.Network.incomingPassword = "uLinkIsAwesome";
               uLink.Network.InitializeServer(32, 25000);
            }
            </code>
      </example>
      <returns>One of the enum <see cref="T:uLink.NetworkConnectionError" /> values, 
            if no errors <see cref="F:uLink.NetworkConnectionError.NoError" /> is returned</returns>
    </member>
    <member name="M:uLink.Network.InitializeServer(System.Int32,System.Int32,System.Boolean)">
      <summary>
            Initializes the server and the bool useProxy indicates if clients must connect via a proxy server.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <overloads>The most basic form of all overloaded Instantiate functions is 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            Please read the documentation for that function first.
            </overloads>
      <summary>
            THE MOST BASIC FORM: Creates a network aware object. Instantiates the specified prefab.
            </summary>
      <remarks>
            We recommend registering the prefab with the utility script uLinkRegisterPrefabs before calling
            this method. Read more about this script in the uLink manual chapter about instatiating objects.
            <para>
            The given prefab will be instantiated on all clients and the server in the game.
            State synchronization is automatically set up so there is no extra work involved
            to start that. Internally in uLink, this is a reliable and buffered internal RPC call.
            </para><para>
            All new clients connecting to the server at a later time will get this RPC so
            that the object is automatically instantiated right after the connection has
            been established (at those clients). This call will default to setting the
            caller (<see cref="T:uLink.NetworkPlayer">uLink.NetworkPlayer</see>) as owner and
            creator for this object. Read more about the three object roles in the uLink
            manual. 
            </para><para>
            Be aware that it is possible to remove this buffered RPC by calling
            the <see cref="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer)">uLink.Network.RemoveRPCs</see>
            function.</para></remarks>
      <param name="prefab">The prefab.</param>
      <param name="position">The position.</param>
      <param name="rotation">The rotation.</param>
      <param name="group">The group number.</param>
      <param name="initialData">Other initial data for this prefab that is needed
            right at the instantiation. Could be anything beside position and rotation. For
            example color, equipment, buffs, hitpoints, etc.</param>
      <returns>
            The newly instantiated GameObject.
            </returns>
      <example>
        <code>
            // Immediately instantiates a new connected player's character
            // when successfully connected to the server.
            // Note: The server is non-authoritative in this example.
            var playerPrefab : Transform;
            
            function uLink_OnConnectedToServer ()
            {
               uLink.Network.Instantiate(playerPrefab, transform.position, transform.rotation, 0);
            }
            </code>
      </example>
    </member>
    <member name="M:uLink.Network.Instantiate``1(``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as object.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Creates a network aware object. Instantiates one prefab for proxies and another for the creator. Can be used for NPCs.
            </summary>
      <remarks>This Instatiate is a more advanced form of 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            This Instantiate is perfect for creating NPCs in an authoritative server. 
            <para>
            When called on the server, the server will have two roles for this object, owner and creator. 
            All clients will have the role proxy for this object and they will all get an instantiated 
            prefab dictated by the argument proxyPrefab. The beauty of this is that the server side 
            instantiated GameObject can have more (sensitive and secret) properties that will not 
            be synchronized to clients.
            </para><para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            Read more about the three object roles in the uLink manual. 
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``1(``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab and ownerPrefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab and ownerPrefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Creates a network aware object and owner is one the first argument. Instantiates the specified prefab. 
            </summary>
      <remarks>This Instantiate function adds an extra parameter to the basic
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            "owner". This can be used to explicitly set the owner of this object to
            another <see cref="T:uLink.NetworkPlayer" />. This Instantiate is perfect for creating player controlled objects 
            on the server. It can be used in both authoritative servers and non-authoritative servers. 
            <para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            </para><para>Read more about the three object roles in the uLink manual.
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as object.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Creates a network aware object. Instantiates three different prefabs, for the owner, for the creator and for the proxies. 
            </summary>
      <remarks>This is a more advanced form of 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            This Instantiate is perfect for creating each player's avatar in an authoritative server. 
            When called on the server, the server will have the "creator" role for this object. The 
            "owner" role is given to the <see cref="T:uLink.NetworkPlayer" /> that will control this avatar. 
            All other clients will have the "proxy" role for this object.
            <para>The beauty of this is that the server side instantiated GameObject, the creator prefab, 
            can have more (sensitive and secret) 
            properties that should never be synchronized to any clients. 
            </para><para>
            Also, if the game uses statesync between the creator and the owner, this statesync can send
            completely different properties compared to the statesync between the creator and the proxies. 
            Read more on this topic in the messages <see cref="!:uLink_OnSerializeNetworkView" /> and 
            <see cref="!:uLink_OnSerializeNetworkViewOwner" />. 
            </para><para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            </para><para>
            Read more about the three object roles in the uLink manual. 
            </para><para>
            It is possible to set proxyPrefab and/or ownerPrefab to null to never use that role. 
            One example when it is smart to set
            proxyPrefab no null is a situation when you want to statesync an object between the owner
            (a player) and the creator (the server), but no other clients should be aware this object. 
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,``0,``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkPlayer,System.String,System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Advanced form: Should only be used if an allocated <see cref="T:uLink.NetworkViewID" /> is already known. 
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkViewID,uLink.NetworkPlayer,``0,``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,System.String,System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <overloads>The most basic form of all overloaded Instantiate functions is 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            Please read the documentation for that function first.
            </overloads>
      <summary>
            THE MOST BASIC FORM: Creates a network aware object. Instantiates the specified prefab.
            </summary>
      <remarks>
            We recommend registering the prefab with the utility script uLinkRegisterPrefabs before calling
            this method. Read more about this script in the uLink manual chapter about instatiating objects.
            <para>
            The given prefab will be instantiated on all clients and the server in the game.
            State synchronization is automatically set up so there is no extra work involved
            to start that. Internally in uLink, this is a reliable and buffered internal RPC call.
            </para><para>
            All new clients connecting to the server at a later time will get this RPC so
            that the object is automatically instantiated right after the connection has
            been established (at those clients). This call will default to setting the
            caller (<see cref="T:uLink.NetworkPlayer">uLink.NetworkPlayer</see>) as owner and
            creator for this object. Read more about the three object roles in the uLink
            manual. 
            </para><para>
            Be aware that it is possible to remove this buffered RPC by calling
            the <see cref="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer)">uLink.Network.RemoveRPCs</see>
            function.</para></remarks>
      <param name="prefab">The prefab.</param>
      <param name="position">The position.</param>
      <param name="rotation">The rotation.</param>
      <param name="group">The group number.</param>
      <param name="initialData">Other initial data for this prefab that is needed
            right at the instantiation. Could be anything beside position and rotation. For
            example color, equipment, buffs, hitpoints, etc.</param>
      <returns>
            The newly instantiated GameObject.
            </returns>
      <example>
        <code>
            // Immediately instantiates a new connected player's character
            // when successfully connected to the server.
            // Note: The server is non-authoritative in this example.
            var playerPrefab : Transform;
            
            function uLink_OnConnectedToServer ()
            {
               uLink.Network.Instantiate(playerPrefab, transform.position, transform.rotation, 0);
            }
            </code>
      </example>
    </member>
    <member name="M:uLink.Network.Instantiate``2(``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as object.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Creates a network aware object. Instantiates one prefab for proxies and another for the creator. Can be used for NPCs.
            </summary>
      <remarks>This Instatiate is a more advanced form of 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            This Instantiate is perfect for creating NPCs in an authoritative server. 
            <para>
            When called on the server, the server will have two roles for this object, owner and creator. 
            All clients will have the role proxy for this object and they will all get an instantiated 
            prefab dictated by the argument proxyPrefab. The beauty of this is that the server side 
            instantiated GameObject can have more (sensitive and secret) properties that will not 
            be synchronized to clients.
            </para><para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            Read more about the three object roles in the uLink manual. 
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``2(``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab and ownerPrefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab and ownerPrefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Creates a network aware object and owner is one the first argument. Instantiates the specified prefab. 
            </summary>
      <remarks>This Instantiate function adds an extra parameter to the basic
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            "owner". This can be used to explicitly set the owner of this object to
            another <see cref="T:uLink.NetworkPlayer" />. This Instantiate is perfect for creating player controlled objects 
            on the server. It can be used in both authoritative servers and non-authoritative servers. 
            <para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            </para><para>Read more about the three object roles in the uLink manual.
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``2(uLink.NetworkPlayer,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,UnityEngine.Object,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except prefab as object.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Creates a network aware object. Instantiates three different prefabs, for the owner, for the creator and for the proxies. 
            </summary>
      <remarks>This is a more advanced form of 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />.
            This Instantiate is perfect for creating each player's avatar in an authoritative server. 
            When called on the server, the server will have the "creator" role for this object. The 
            "owner" role is given to the <see cref="T:uLink.NetworkPlayer" /> that will control this avatar. 
            All other clients will have the "proxy" role for this object.
            <para>The beauty of this is that the server side instantiated GameObject, the creator prefab, 
            can have more (sensitive and secret) 
            properties that should never be synchronized to any clients. 
            </para><para>
            Also, if the game uses statesync between the creator and the owner, this statesync can send
            completely different properties compared to the statesync between the creator and the proxies. 
            Read more on this topic in the messages <see cref="!:uLink_OnSerializeNetworkView" /> and 
            <see cref="!:uLink_OnSerializeNetworkViewOwner" />. 
            </para><para>
            The rest of the arguments are handled just like in 
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />. 
            </para><para>
            Read more about the three object roles in the uLink manual. 
            </para><para>
            It is possible to set proxyPrefab and/or ownerPrefab to null to never use that role. 
            One example when it is smart to set
            proxyPrefab no null is a situation when you want to statesync an object between the owner
            (a player) and the creator (the server), but no other clients should be aware this object. 
            </para></remarks>
    </member>
    <member name="M:uLink.Network.Instantiate``2(uLink.NetworkPlayer,``0,``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkPlayer,System.String,System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Advanced form: Should only be used if an allocated <see cref="T:uLink.NetworkViewID" /> is already known. 
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``2(uLink.NetworkViewID,uLink.NetworkPlayer,``0,``0,``0,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``1)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab as component.
            </summary>
    </member>
    <member name="M:uLink.Network.Instantiate``1(uLink.NetworkViewID,uLink.NetworkPlayer,System.String,System.String,System.String,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,``0)">
      <summary>
            Same as <see cref="M:uLink.Network.Instantiate(uLink.NetworkViewID,uLink.NetworkPlayer,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" /> except proxyPrefab, ownerPrefab and serverPrefab as string.
            </summary>
    </member>
    <member name="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer)">
      <overloaded>Remove buffered RPCs</overloaded>
      <summary>
            Remove all buffered RPCs that was sent by target player (argument sender).
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCs(uLink.NetworkPlayer,uLink.NetworkGroup)">
      <summary>
            Remove all buffered RPCs that was sent by target player (argument sender) for just one <see cref="T:uLink.NetworkGroup" />.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCs(uLink.NetworkViewID)">
      <summary>
            Remove all buffered RPCs which belong to one viewID.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveAllRPCs">
      <summary>
            Remove all buffered RPCs.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsInGroup(uLink.NetworkGroup)">
      <summary>
            Remove all RPCs which belongs to one group.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsByName(uLink.NetworkGroup,System.String)">
      <overloaded>Remove buffered RPCs by RPC name</overloaded>
      <summary>
            Remove all buffered RPCs which belong to viewIDs in the specificed group and has the specified name.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsByName(uLink.NetworkViewID,System.String)">
      <overloaded>Remove buffered RPCs by RPC name</overloaded>
      <summary>
            Remove all buffered RPCs which belong to one viewID and has the specified name.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsByName(uLink.NetworkPlayer,System.String)">
      <summary>
            Remove all buffered RPCs that was sent by target player (argument sender) and has the specified name.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveRPCsByName(System.String)">
      <summary>
            Remove all buffered RPCs that has the specified name.
            </summary>
      <remarks>Does not remove buffered Instantiate RPCs.</remarks>
    </member>
    <member name="M:uLink.Network.RemoveInstantiate(uLink.NetworkViewID)">
      <summary>
            Remove one instantiating RPC from the RPC buffer.
            </summary>
    </member>
    <member name="M:uLink.Network.RemoveInstantiates(uLink.NetworkPlayer)">
      <summary>
            Remove all instantiating RPC which has this sender from the RPC buffer.
            </summary>
    </member>
    <member name="M:uLink.Network.RemoveInstantiates(uLink.NetworkPlayer,uLink.NetworkGroup)">
      <summary>
            Remove all instantiating RPC from RPC buffer with this sender and this group.
            </summary>
    </member>
    <member name="M:uLink.Network.RemoveInstantiatesInGroup(uLink.NetworkGroup)">
      <summary>
            Remove all instantiating RPCs from RPC buffer belonging to the group.
            </summary>
    </member>
    <member name="M:uLink.Network.RemoveInstantiatingRPCs(uLink.NetworkPlayer)">
      <overloaded>Obsolete.</overloaded>
    </member>
    <member name="M:uLink.Network.RemoveAllInstantiates">
      <summary>
            Removes all instantiating RPCs from the RPC buffer.
            </summary>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkViewID,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkViewID,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkFlags,uLink.NetworkViewID,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.RPC(uLink.NetworkFlags,uLink.NetworkViewID,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.UnreliableRPC(uLink.NetworkViewID,System.String,uLink.NetworkPlayer,System.Object[])">
      <summary>
            Sends an RPC over an unreliable channel in uLink.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.UnreliableRPC(System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.UnreliableRPC(uLink.NetworkViewID,System.String,uLink.RPCMode,System.Object[])">
      <summary>
            Sends an RPC over an unreliable channel in uLink.
            </summary>
      <remarks>Works exactly like <see cref="M:uLink.NetworkView.UnreliableRPC(System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.Network.SetLevelPrefix(System.Int32)">
      <summary>
            Sets the level prefix. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="M:uLink.Network.SetReceivingEnabled(uLink.NetworkPlayer,uLink.NetworkGroup,System.Boolean)">
      <summary>
            Turn on or off the receiving of network traffic. Deprecated.
            </summary>
      <remarks>SetReceivingEnabled is deprecated, please use <see cref="M:uLink.Network.AddPlayerToGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> or <see cref="M:uLink.Network.RemovePlayerFromGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> instead.</remarks>
    </member>
    <member name="M:uLink.Network.SetSendingEnabled(uLink.NetworkGroup,System.Boolean)">
      <summary>
            Turn on or off the sending of network traffic for one group only. Deprecated.
            </summary>
      <remarks>SetSendingEnabled is deprecated, please use <see cref="M:uLink.Network.AddPlayerToGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> or <see cref="M:uLink.Network.RemovePlayerFromGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> instead.</remarks>
    </member>
    <member name="M:uLink.Network.SetSendingEnabled(uLink.NetworkPlayer,uLink.NetworkGroup,System.Boolean)">
      <summary>
            Turn on or off the sending of network traffic. Deprecated.
            </summary>
      <remarks>SetSendingEnabled is deprecated, please use <see cref="M:uLink.Network.AddPlayerToGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> or <see cref="M:uLink.Network.RemovePlayerFromGroup(uLink.NetworkPlayer,uLink.NetworkGroup)" /> instead.</remarks>
    </member>
    <member name="M:uLink.Network.TestConnection">
      <summary>
            Test this machines network connection. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="M:uLink.Network.TestConnection(System.Boolean)">
      <summary>
            Test this machines network connection. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="M:uLink.Network.TestConnectionNAT">
      <summary>
            Test the connecction specifically for NAT punchthrough connectivity. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.Int32)">
      <overloads>Redirects the client to another server. 
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </overloads>
      <summary>
            Redirects the client to another server on the same host.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.Int32,System.String)">
      <summary>
            Redirects the client to another server on the same host.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.Net.IPEndPoint)">
      <summary>
            Redirects the client to another server.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.Net.IPEndPoint,System.String)">
      <summary>
            Redirects the client to another server.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.String,System.Int32)">
      <summary>
            Redirects the client to another server.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.RedirectConnection(uLink.NetworkPlayer,System.String,System.Int32,System.String)">
      <summary>
            Redirects the client to another server.
            </summary>
      <remarks>Use this function on the server to make a client 
            disconnect and after that connect to a new server.
            Triggers the callback <see cref="!:uLink_OnRedirectingToServer" /> in the client.
            </remarks>
    </member>
    <member name="M:uLink.Network.InitializeSecurity">
      <summary>
            Initializes security for all current and future players on the server.
            </summary>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityInitialized" /> callback is sent as security is turned on for each players session.
            </remarks>
    </member>
    <member name="M:uLink.Network.InitializeSecurity(System.Boolean)">
      <summary>
            Initializes security for all future players and optionally already connected players.
            </summary>
      <param name="includingCurrentPlayers">Whether or not to intialize security for already connected players.</param>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityInitialized" /> callback is sent as security is turned on for each players session.
            </remarks>
    </member>
    <member name="M:uLink.Network.InitializeSecurity(uLink.NetworkPlayer)">
      <summary>
            Initializes security for a specific player.
            </summary>
      <remarks>
            Use this only on the server to turn on security for one player after
            the connection was made. 
            <see cref="!:uLink_OnSecurityInitialized" /> callback is sent once the players session is secured. Security in
            clients can be turned on before connecting by assigning <see cref="P:uLink.Network.publicKey" /></remarks>
    </member>
    <member name="M:uLink.Network.UninitializeSecurity">
      <summary>
            Removes security for all current and future players.
            </summary>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityUninitialized" />
            callbacks are sent as security is removed from each players session.
            </remarks>
    </member>
    <member name="M:uLink.Network.UninitializeSecurity(System.Boolean)">
      <summary>
            Remove security for all future players and optionally already connected players.
            </summary>
      <param name="includingCurrentPlayers">Whether or not to remove security for already connected players.</param>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityUninitialized" /> callback is sent as security is removed from each players session.
            </remarks>
    </member>
    <member name="M:uLink.Network.UninitializeSecurity(uLink.NetworkPlayer)">
      <summary>
            Removes security for a specific player.
            </summary>
      <remarks>
            Use this only on the server. <see cref="!:uLink_OnSecurityUninitialized" /> callback is sent once security is removed from the players session.
            </remarks>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.String)">
      <summary>
            Starts the server as a cell server and connects it Pikko Server.
            </summary>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.String[])">
      <summary>
            Starts the server as a cell server and connects it Pikko Server.
            </summary>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.Net.IPEndPoint)">
      <summary>
            Starts the server as a cell server and connects it Pikko Server.
            </summary>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.String,System.Int32)">
      <summary>
            Starts the server as a cell server and connects it Pikko Server.
            </summary>
    </member>
    <member name="M:uLink.Network.InitializeCellServer(System.Int32,System.String[],System.Int32)">
      <summary>
            Starts the server as a cell server and connects it Pikko Server.
            </summary>
    </member>
    <member name="P:uLink.Network.requireSecurityForConnecting">
      <summary>
            Gets or sets if a uLink client requires a public key before connecting to the server.
            </summary>
      <remarks>This value is only used in clients. If true, the client can only connect 
            to a server if the public key has been provided with <see cref="P:uLink.Network.publicKey" />. 
            Default value is <c>false</c>.</remarks>
    </member>
    <member name="P:uLink.Network.licenseKey">
      <summary>
            Gets or sets the uLink licenseKey.
            </summary>
    </member>
    <member name="P:uLink.Network.symmetricKeySize">
      <summary>
            Gets or sets the symmetricKeySize.
            </summary>
    </member>
    <member name="P:uLink.Network.lastError">
      <summary>
            Gets the last returned <see cref="T:uLink.NetworkConnectionError" />.
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkConnectionError.NoError" /></value>
    </member>
    <member name="P:uLink.Network.networkViews">
      <summary>
            Gets an array of all instantiated networkViews.
            </summary>
    </member>
    <member name="P:uLink.Network.networkViewCount">
      <summary>
            Gets the number of instantiated networkViews.
            </summary>
    </member>
    <member name="P:uLink.Network.connections">
      <summary>
            Gets all connected players.
            </summary>
      <remarks>
            On a client this array contains only the server.
            </remarks>
      <example>
            This javascript example can be run on a server with GUI. When you hit the button a player will be disconnected.
            <code>
            function OnGUI() {
               if (GUILayout.Button ("Disconnect first player")) {
                   if (uLink.Network.connections.length &gt; 0) {
                       Debug.Log("Disconnecting: "+
                           uLink.Network.connections[0].ipAddress+":"+uLink.Network.connections[0].port);
                       uLink.Network.CloseConnection(uLink.Network.connections[0], true);
                   } 
               }    
            }
            </code></example>
    </member>
    <member name="P:uLink.Network.connectionTesterIP">
      <summary>
            Gets or sets the connection tester IP. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future.</remarks>
    </member>
    <member name="P:uLink.Network.connectionTesterPort">
      <summary>
            Gets or sets the connection tester port. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future.</remarks>
    </member>
    <member name="P:uLink.Network.incomingPassword">
      <summary>
            Gets or sets the password for the server (for incoming connections).
            </summary>
      <remarks>This must be matched in the 
            clients. Pass "" to specify no password (this is default).</remarks>
      <example>
        <code>
            function ConnectToServer () {
               Network.Connect("127.0.0.1", 25000, "HolyMoly");
            }
            
            function LaunchServer () {
               Network.incomingPassword = "HolyMoly";
               Network.InitializeServer(32, 25000);
            }
            </code>
      </example>
    </member>
    <member name="P:uLink.Network.isClient">
      <summary>
            Gets a value indicating whether this instance is a uLink client.
            </summary>
      <value>
        <c>true</c> if this instance is client; otherwise, <c>false</c>. 
            Returns true even if the client's <see cref="P:uLink.Network.status" /> is connecting.</value>
    </member>
    <member name="P:uLink.Network.isMessageQueueRunning">
      <summary>
            Enable or disable the processing of incoming network messages. No messages are discarded.
            </summary>
      <remarks>This feature can be used to stop all incoming network traffic in a client, 
            for example when the client is loading a level. The statesync and RPC messages are not discarded by uLink. 
            They are delivered later when this value is set to <c>true</c>.
            There is no limit for the message queue, so please do not turn this off in a client unless you plan 
            to turn it on again, otherwise the client might end up with a memory leak.
            </remarks>
      <value>
        <c>true</c> when incoming network messages are processed; otherwise, <c>false</c>. Default value is true.
            </value>
    </member>
    <member name="P:uLink.Network.isServer">
      <summary>
            Gets a value indicating whether this instance is a server.
            </summary>
      <value>
        <c>true</c> if this instance is server; otherwise, <c>false</c>. 
            Returns true even if the server's <see cref="P:uLink.Network.status" /> is connecting.</value>
    </member>
    <member name="P:uLink.Network.maxConnections">
      <summary>
            Gets or sets the maximum number of connections/players allowed on a server.
            </summary>
      <remarks>
            This cannot be set higher than 
            the connection count given in <see cref="O:uLink.Network.InitializeServer" />.
            In addition, there are two special values, 0 and -1. Setting it to 0 means no new connections 
            can be made but the existing ones stay connected. Setting it to -1 means the maximum 
            connection count is set to the number of currently open connections. 
            </remarks>
    </member>
    <member name="P:uLink.Network.maxManualViewIDs">
      <summary>
            Gets or sets the maximum number of manualViewIDs that are available for usage.
            </summary>
      <value>Default value is 1000.</value>
      <remarks>
            Increase this value if there is a need to assign more than 1000 manualViewIDs is the game.
            </remarks>
    </member>
    <member name="P:uLink.Network.minimumAllocatableViewIDs">
      <summary>
            The minimum number of entries in the clients pool of unused ViewIDs.
            </summary>
      <value>Default value is 1000.</value>
      <remarks>
            This value is interesting when creating a game with clients that make lots of Instantiate calls, 
            thus being authoritative clients.
            A ViewID pool is given to each client when it connects. The size of the pool is dictated by this property plus 
            the property <see cref="P:uLink.Network.minimumUsedViewIDs" />. The client starts to allocate these viewIDs 
            one by one for every Instantiate call. When the unused (free) number of viewIDs reach this minimum in the client,
            uLink will make a call to the server to get more (unused) viewIDs.   
            The server and clients should be in sync regarding this value. Setting this higher only on the server has the effect that it sends more 
            view ID numbers to clients, than they really want. Setting this higher only on clients 
            means they request more view IDs more often, for example twice in a row, as the pools 
            received from the server don't contain enough numbers.
            
            </remarks>
      <example>
        <code>
            function Awake () {
               // Use this setting on both client and server.
               Network.minimumAllocatableViewIDs = 500;
            }
            </code>
      </example>
    </member>
    <member name="P:uLink.Network.minimumUsedViewIDs">
      <summary>
            The number of viewIDs each client is supposed to use (allocate) in a normal game session. 
            </summary>
      <value>Default value is 1</value>
      <remarks>
            This value is interesting when creating a game with clients that make lots of Instantiate 
            calls, thus being authoritative clients. A ViewID pool is given to each client when it 
            connects. The size of the pool is dictated by this property plus the property 
            <see cref="P:uLink.Network.minimumAllocatableViewIDs" />. To make the pool size bigger by default just 
            increase this number. The motive for increasing this number is that the clients making 
            many Instantiate calls want to get bigger "chunks" of unused viewIDs when the client connects and 
            also whenever the client reaches its <see cref="P:uLink.Network.minimumAllocatableViewIDs" />. This reduces the 
            amount if uLink internal RPCs to the server to allocate more viewIDs.
            </remarks>
      <example>In an FPS game where players shoot at each other with rockets and the rockets are 
            network aware objects it could be wise to increase this number.</example>
    </member>
    <member name="P:uLink.Network.natFacilitatorIP">
      <summary>
            Gets or sets the NAT facilitator IP. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="P:uLink.Network.natFacilitatorPort">
      <summary>
            Gets or sets the NAT facilitator port. Not implemented yet.
            </summary>
      <remarks>Not implemented yet. If feature requested, will likely be part of uLink in the future. </remarks>
    </member>
    <member name="P:uLink.Network.status">
      <summary>
            Gets the <see cref="T:uLink.NetworkStatus" /> of this network peer (<see cref="T:uLink.NetworkPeerType" />).
            </summary>
    </member>
    <member name="P:uLink.Network.listenPort">
      <summary>
            Gets the UDP port number for the socket uLink has opened.
            </summary>
      <return>0 if the socket is not open.</return>
    </member>
    <member name="P:uLink.Network.peerType">
      <summary>
            Gets the type of this network peer.
            </summary>
    </member>
    <member name="P:uLink.Network.player">
      <summary>
            Gets the player at this peer/host.
            </summary>
      <remarks>On the server this get call will return the special 
            <see cref="T:uLink.NetworkPlayer" /> indicating this is a server 
            (uLink.NetworkPlayer.<see cref="F:uLink.NetworkPlayer.server" />).
            </remarks>
    </member>
    <member name="P:uLink.Network.useProxy">
      <summary>
            Indicates if it is required that clients connect via a proxy
            </summary>
      <remarks>
            Set this value to true in a game server before regestering the server in the master server.
            Read more about the master server and the proxy server in the Master Server and Proxy manual chapter.
            </remarks>
    </member>
    <member name="P:uLink.Network.proxyIP">
      <summary>Not in use.</summary>
      <remarks>Read the Master Server and Proxy manual chapter. It explains how to use the Proxy Server.</remarks>
    </member>
    <member name="P:uLink.Network.proxyPassword">
      <summary>Not in use.</summary>
      <remarks>Read the Master Server and Proxy manual chapter. It explains how to use the Proxy Server.</remarks>
    </member>
    <member name="P:uLink.Network.proxyPort">
      <summary>Not in use.</summary>
      <remarks>Read the Master Server and Proxy manual chapter. It explains how to use the Proxy Server.</remarks>
    </member>
    <member name="P:uLink.Network.sendRate">
      <summary>
            Gets or sets the send rate for state synchronizations from this peer/host.
            </summary>
      <value>The default value is 15.</value>
      <remarks>Fast paced games like FPS games should use 15-25. Other games can use any value. This value is the most (server-side) bandwidth 
            sensitive configuration in uLink, at least if the usage of statesync in the game is extensive.</remarks>
      <example>
        <code>
            function Awake ()
            {
                // Increase default send rate
                uLink.Network.sendRate = 25;
            }
            </code>
      </example>
    </member>
    <member name="P:uLink.Network.trackRate">
      <summary>
            Cell Server only: Gets or sets the send rate for track position messages sent from this cell server.
            </summary>
    </member>
    <member name="P:uLink.Network.trackMaxDelta">
      <summary>
            Cell Server only: Gets or sets the max delta distance that an object can move without sending track position messages (from this cell server).
            </summary>
    </member>
    <member name="P:uLink.Network.time">
      <summary>
            Gets the current network time in seconds. 
            </summary>
      <remarks>
            This value starts at 0 when the server starts. 
            If a uLink client hasn't yet connected to a server or a server hasn't been initialized, 0 is returned.
            <para>
            The network time on all connected clients is synchronized by uLink. 
            Each client is synchronized just once, during the internal uLink connection sequence.
            The ping time during the client's connection is divided in half to 
            set the time offset for this client, 
            that will be used in the client until it is disconnected.
            </para><para>
            Be aware of the fact that this time value, in the client, is based on the local clock after 
            the initial connection and therefore changes in ping time can make the server time and client 
            time appear to run with fluctuating speeds. Try to compare client time stamps with other client stamps 
            and server time stamps with other server time stamps to avoid subtile bugs that will appear 
            only when the ping time changes. When comparing client time stamps with server time stamps, be careful.
            </para><para>
            uLink uses two separate local CPU clocks to make sure the value for Network.time is always correct 
            and very accurate on several different hardwares.
            </para></remarks>
      <example>This value can, for example, be used to compare with the time 
            returned in <see cref="T:uLink.NetworkMessageInfo" />.
            <code>
            var something : float;
            var transitTime: double;
            
            function uLink_OnSerializeNetworkView (stream : uLink.BitStream, info : uLink.NetworkMessageInfo) {
               var horizontalInput : float = 0.0;
               if (stream.isWriting) {
                  // Sending
                  horizontalInput = transform.position.x;
                  stream.Serialize (horizontalInput);
               } else {
                  // Receiving
                  transitTime	= Network.time - info.timestamp;
                  stream.Serialize (horizontalInput);
                  something =	horizontalInput;
               }
            }
            
            function OnGUI() {
               GUILayout.Label("Last transmission time: " + transitTime);
            }
            </code></example>
    </member>
    <member name="P:uLink.Network.timeInMillis">
      <summary>
            Gets the current network time in milliseconds. 
            </summary>
      <remarks>Works just like <see cref="P:uLink.Network.time" />, except the 
            returned value is rounded to the the closest millisecond. 
            </remarks>
      <example>This can, for example, be used to compare with the time 
            returned in <see cref="T:uLink.NetworkMessageInfo" />.
            <code>
            var something : float;
            var transitTimeInMillis: ulong;
            
            function uLink_OnSerializeNetworkView (stream : uLink.BitStream, info : uLink.NetworkMessageInfo) {
               var horizontalInput : float = 0.0;
               if (stream.isWriting) {
                  // Sending
                  horizontalInput = transform.position.x;
                  stream.Serialize (horizontalInput);
               } else {
                  // Receiving
                  transitTimeInMillis = Network.timeInMillis - info.timestampInMillis;
                  stream.Serialize (horizontalInput);
                  something = horizontalInput;
               }
            }
            
            function OnGUI() {
               GUILayout.Label("Last transmission time: " + timestampInMillis);
            }
            </code></example>
    </member>
    <member name="P:uLink.Network.useNat">
      <summary>
            Gets or sets a value indicating whether to use NAT punchthrough.
            </summary>
      <value>
        <c>true</c> if using NAT punchthrough; otherwise, <c>false</c>. Default is false.</value>
      <remarks>Read more on this subject in the manual and the <see cref="T:uLink.MasterServer" />.</remarks>
    </member>
    <member name="P:uLink.Network.rpcTypeSafe">
      <summary>
            Gets or sets a <see cref="T:uLink.RPCTypeSafe" /> value indicating whether the parameters in RPCs will be type
            safe or not.
            </summary>
      <value>Type safety is set to <see cref="F:uLink.RPCTypeSafe.OnlyInEditor" /> by default,
            which means it will only be turned on when running uLink in the Unity editor, so that you can find
            bugs early in development. I.e. if you run uLink outside the editor it will be turned off by default.
            Change this value to overrule the default behavior.
            It is common to run clients outside the editor and the server in the editor,
            and uLink can handle this without problems, but in that case you will only get type saftey
            when sending from the server (in the editor) and not on RPCs that are sent from the clients (outside the editor).</value>
      <remarks>If type safety is turned on it will increase RPC's packet size by
            one extra byte for each RPC parameter, so that it can tell the receiver the
            expected <see cref="T:uLink.BitStreamTypeCode" />. The purpose is to avoid subtile bugs like
            sending an integer but receiving it as a float. When type safety is
            turned on uLink will throw an exception when a RPC parameter
            doesn't match the recievers function declaration. The price for type
            safety is increased bandwidth.</remarks>
    </member>
    <member name="P:uLink.Network.isCellServer">
      <summary>
            Gets a value indicating whether this instance is a cell server.
            </summary>
      <remarks>Cell servers are game servers connected using Pikko Server in a distributed 
            system of game servers to make the virtual world seamless. Read more 
            about this in the Pikko Server MMO manual chapter.</remarks>
    </member>
    <member name="P:uLink.Network.isClientOrCellServer">
      <summary>
            Returns true if this is a uLink client or cell server, otherwise false.
            </summary>
    </member>
    <member name="P:uLink.Network.isServerOrCellServer">
      <summary>
            Returns true if this is a uLink server or cell server, otherwise false.
            </summary>
    </member>
    <member name="P:uLink.Network.isAuthoritativeServer">
      <summary>
            Gets or sets a value indicating whether this instance is an authoritative server.
            </summary>
      <remarks>This is an important strategic choice when building a 
            multiplayer game. By making the server authoritative, clients are prevented from performing dangerous operations 
            such as sending RPC:s to other players (via the server). Authoritative servers will not receive statesync 
            from clients. Most commercial game servers are authoritative for security reasons.
            Read more in the uLink manual's section on Authoritative server.</remarks>
    </member>
    <member name="P:uLink.Network.useDifferentStateForOwner">
      <summary>
            Dictates if the statesync sent to the owner will be different from proxy statesync and thus handled separately.
            </summary>
      <value>Default is true</value>
      <remarks>This value is only useful in an authoritative server. When <c>true</c>, the statesync to owner 
            will be sent separately and thus can be received separately. 
            Take a look at the callback <see cref="!:uLink_OnSerializeNetworkViewOwner" />, it will be called on the 
            receiver that is the owner for the object and on the server sending this kind of statesync. 
            Statesync to proxy objects will be handled the normal way in <see cref="!:uLink_OnSerializeNetworkView" />. 
            When this value is set to false, the callback <see cref="!:uLink_OnSerializeNetworkView" /> will be used for all statesyncs. 
            </remarks>
    </member>
    <member name="P:uLink.Network.useRedirect">
      <summary>
            Setting this value to true in the server causes all future connection attempts 
            to be automatically redirected.
            </summary>
      <remarks>All connection attempts to this server will be redirected to the server 
            specified by the <see cref="P:uLink.Network.redirectIP" /> and <see cref="P:uLink.Network.redirectPort" /> (and 
            optionally <see cref="P:uLink.Network.redirectPassword" />) properties.
            </remarks>
    </member>
    <member name="P:uLink.Network.redirectIP">
      <summary>
            The host domain name or IP to connect to when the <see cref="P:uLink.Network.useRedirect" /> property is set to true.
            </summary>
      <remarks>
            If the redirect is to a uLink server with the same IP, only the port is different, 
            set this property to <see cref="F:System.Net.IPAddress.Any" />.
            </remarks>
    </member>
    <member name="P:uLink.Network.redirectPassword">
      <summary>
            The password to use (if needed) when the <see cref="P:uLink.Network.useRedirect" /> property is set to true.
            </summary>
    </member>
    <member name="P:uLink.Network.redirectPort">
      <summary>
            The port to connect to when the <see cref="P:uLink.Network.useRedirect" /> property is set to true.
            </summary>
    </member>
    <member name="P:uLink.Network.approvalData">
      <summary>
            Gets the approval data sent from the server, that can be used in the client right after a connection is established
            </summary>
      <remarks>This is the <see cref="T:uLink.BitStream" /> the client can read when the approval data needs to be handled.
            The code for checking approvalData should always be placed in the callback <see cref="!:uLink_OnConnectedToServer" />. 
            If you need to read the approvalData later (again) for some reason, it is available via this propery.
            </remarks>
      <example>ApprovalData can be anything the server sends to a newly connected client. It could be information about 
            which level to load and information about which RPC groups the client should avoid.</example>
    </member>
    <member name="P:uLink.Network.loginData">
      <summary>
            A client can get the loginData via this property, the loginData that 
            was included and sent to the server when Connect was called. 
            </summary>
      <remarks>
            The purpose of this property is that sometimes it is handy to to check 
            what data was sent to the server when the connection was made.</remarks>
    </member>
    <member name="P:uLink.Network.publicKey">
      <summary>
            Specifies a user-defined public RSA key. This method should be used on the client-side only.
            </summary>
      <remarks>
            By setting the public key that corresponds to the server all connection attempts from this 
            client will be encrypted and the connection
            will only be successful to a server with the corresponding private key.
            </remarks>
    </member>
    <member name="P:uLink.Network.privateKey">
      <summary>
            Gets of sets a user-defined private RSA key. This should be set on the server-side only.
            </summary>
    </member>
    <member name="P:uLink.Network.emulation">
      <summary>
            Gets or sets the emulation of network problems like max bandwidth, packet loss, duplicate packets and latecy fluctuations.
            </summary>
      <remarks>
            Use this to test your game with some network issues that are common in the real world before releasing your game. 
            </remarks>
    </member>
    <member name="P:uLink.Network.config">
      <summary>
            Gets or sets configuration for low-level connection parameters, like timeouts, handshake attempts and ping frequency.
            </summary>
      <remarks>
            Use this to fine-tune the behavior of the underlying uLink protocol for maximum networking performance.
            </remarks>
    </member>
    <member name="P:uLink.Network.logLevel">
      <summary>
            Gets or sets the loglevel for uLink logging.
            </summary>
    </member>
    <member name="T:uLink.MasterServer">
      <summary>
            Use methods in this class to communicate with a stand alone uLink Master Server. 
            </summary>
      <remarks> The Master 
            Server can be used as a listing server (lobby) for game servers. 
            You can advertise game
            hosts or fetch host lists for your specific game type using this class. The
            methods here are used to communicate with the Master Server itself
            which is hosted separately without the need of the Unity editor. 
            For an overview of the Master Server as well as
            usage introduction see the section Master Server in the manual. 
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.ClearHostList">
      <summary>
            Clear the host list which was received from the stand alone master server. See <see cref="M:uLink.MasterServer.PollHostList" />. 
            </summary>
      <remarks>See the code example in <see cref="M:uLink.MasterServer.RequestHostList(System.String)" /></remarks>
    </member>
    <member name="M:uLink.MasterServer.PollHostList">
      <summary>
            Returns the latest host list received from the MasterServer. See <see cref="M:uLink.MasterServer.RequestHostList(System.String)" />.
            </summary>
      <remarks>You can clear the current host list with <see cref="M:uLink.MasterServer.ClearHostList" />. 
            Then way you can be sure that the next list returned is up to date.
            See the code example in <see cref="M:uLink.MasterServer.RequestHostList(System.String)" /></remarks>
    </member>
    <member name="M:uLink.MasterServer.RegisterHost(System.String,System.String)">
      <summary>
            Register this game server on the master server. 
            </summary>
      <remarks>
            This method will also set the values for, <see cref="P:uLink.MasterServer.gameType" /> 
            and <see cref="P:uLink.MasterServer.gameName" />.
            Remember to set the master server ip and port before calling this function.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.RegisterHost(System.String,System.String,System.String)">
      <summary>
            Register this game server on the master server. 
            </summary>
      <remarks>
            This method will also set the values for, <see cref="P:uLink.MasterServer.gameType" />, 
            <see cref="P:uLink.MasterServer.gameName" /> and <see cref="P:uLink.MasterServer.comment" />.
            Remember to set the master server ip and port before calling this function.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.RegisterHost(System.String,System.String,System.String,System.String,System.String)">
      <summary>
            Register this game server on the master server. 
            </summary>
      <remarks>
            This method will also set the values for, <see cref="P:uLink.MasterServer.gameType" />, 
            <see cref="P:uLink.MasterServer.gameName" />, <see cref="P:uLink.MasterServer.comment" />, <see cref="P:uLink.MasterServer.gameMode" /> and <see cref="P:uLink.MasterServer.gameLevel" />.
            Remember to set the master server ip and port before calling this function.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.RegisterHost">
      <summary>
            Register this game server on the master server. 
            </summary>
      <remarks>You have to set <see cref="P:uLink.MasterServer.gameType" /> and <see cref="P:uLink.MasterServer.gameName" /> before calling this method.
            Also, remember to set the master server ip and port before calling this function.</remarks>
    </member>
    <member name="M:uLink.MasterServer.UnregisterHost">
      <summary>
            Unregister this game server on the master server. 
            </summary>
      <remarks>
            Does nothing if the server is not registered or has already unregistered.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.RequestHostList(System.String)">
      <summary>
             Request a host list from the master server for a specific game type.
             </summary>
      <remarks>
             This request is asynchronous, it does not return the result right away. Instead, the result 
             list is available through uLink.MasterServer.<see cref="M:uLink.MasterServer.PollHostList" /> when it has arrived.
             </remarks>
      <example>
        <code>
             function Awake() {
                // Make sure list is empty and request a new list
                MasterServer.ClearHostList();
                MasterServer.RequestHostList("uLinkGames");
             }
            
             function Update() {
                // If any hosts were received, display game name, the clear host list again
                if (MasterServer.PollHostList().length != 0) {
                   var hostData: HostData[] = MasterServer.PollHostList();
                   for (var i:int=0; i &lt; hostData.length; i++) {
                   Debug.Log("Game name: " + hostData[i].gameName);
                }
                   MasterServer.ClearHostList();
                }
             }
             </code>
      </example>
    </member>
    <member name="M:uLink.MasterServer.RequestHostList(uLink.HostDataFilter)">
      <summary>
            Request a host list from the master server that matches a specific filter.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.PollAndRequestHostList(System.String,System.Single)">
      <summary>
            Returns the latest host list received from the MasterServer and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <remarks>This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.</remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndRequestHostList(uLink.HostDataFilter,System.Single)">
      <summary>
            Returns the latest host list received from the MasterServer and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <remarks>This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.</remarks>
    </member>
    <member name="M:uLink.MasterServer.ClearDiscoveredHosts">
      <summary>
            Clear the host list of discovered game servers in the LAN. See <see cref="M:uLink.MasterServer.PollDiscoveredHosts" />. 
            </summary>
    </member>
    <member name="M:uLink.MasterServer.PollDiscoveredHosts">
      <summary>
            Returns the latest host list of all discoved host in the LAN. See <see cref="O:DiscoverLocalHosts" />.
            </summary>
      <remarks>You can clear the current host list with <see cref="M:uLink.MasterServer.ClearDiscoveredHosts" />. 
            That way you can be sure that the next list returned 
            (after calling <see cref="O:DiscoverLocalHosts" />) is up to date.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.DiscoverLocalHosts(System.String,System.Int32)">
      <summary>
            Request a host list of all available game servers in the LAN for a specific game type.
            </summary>
      <param name="gameType">The game type of the game server(s)</param>
      <param name="remotePort">The port number of the game server(s)</param>
      <remarks>
            This request is asynchronous and it is sent to the IPAdress <see cref="F:System.Net.IPAddress.Broadcast" />.
            uLink collects all the answers from running game servers in the LAN and stores the result internally.
            This method does not return the result. Instead, the result 
            list is populated when results come in one by one, and the result is available through 
            uLink.MasterServer.<see cref="M:uLink.MasterServer.PollDiscoveredHosts" />.  
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.DiscoverLocalHosts(uLink.HostDataFilter,System.Int32)">
      <summary>
            Request a host list of all available game servers in the LAN using a filter.
            </summary>
      <param name="filter">The filter for finding only specific game servers.</param>
      <param name="remotePort">The port number of the game server(s)</param>
      <remarks>
            This request is asynchronous and it is sent to the IPAdress <see cref="F:System.Net.IPAddress.Broadcast" />.
            uLink collects all the answers from running game servers in the LAN and stores the result internally.
            This method does not return the result. Instead, the result 
            list is populated when results come in one by one, and the result is available through 
            uLink.MasterServer.<see cref="M:uLink.MasterServer.PollDiscoveredHosts" />.  
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.DiscoverLocalHosts(System.String,System.Int32,System.Int32)">
      <summary>
            Request a host list of all available game servers in the LAN for a specific game type.
            </summary>
      <param name="gameType">The game type of the game server(s)</param>
      <param name="remoteStartPort">The lowest port number of the game servers</param>
      <param name="remoteEndPort">The highest port number of the game servers</param>
      <remarks>
            This request is asynchronous and it is sent to the IPAdress <see cref="F:System.Net.IPAddress.Broadcast" />.
            uLink collects all the answers from running game servers in the LAN and stores the result internally.
            The request will be sent to all UDP ports beginning with remoteStartPort and ending with remoteEndPort.
            The usage of several ports is necessary when there are several game servers hosted on a single machine, 
            since the game servers on one machine need one unique port each.
            This method does not return the result. Instead, the result 
            list is populated when results come in one by one, and the result is available through 
            uLink.MasterServer.<see cref="M:uLink.MasterServer.PollDiscoveredHosts" />.  
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.DiscoverLocalHosts(uLink.HostDataFilter,System.Int32,System.Int32)">
      <summary>
            Request a host list of all available game servers in the LAN using a filter.
            </summary>
      <param name="filter">The filter for finding only specific game servers</param>
      <param name="remoteStartPort">The lowest port number of the game servers</param>
      <param name="remoteEndPort">The highest port number of the game servers</param>
      <remarks>
            This request is asynchronous and it is sent to the IPAdress <see cref="F:System.Net.IPAddress.Broadcast" />.
            uLink collects all the answers from running game servers in the LAN and stores the result internally.
            The request will be sent to all UDP ports beginning with remoteStartPort and ending with remoteEndPort.
            The usage of several ports is necessary when there are several game servers hosted on a single machine, 
            since the game servers on one machine need one unique port each.
            This method does not return the result. Instead, the result 
            list is populated when results come in one by one, and the result is available through 
            uLink.MasterServer.<see cref="M:uLink.MasterServer.PollDiscoveredHosts" />.  
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndDiscoverLocalHosts(System.String,System.Int32,System.Single)">
      <summary>
            Returns the latest host list discovered on the LAN and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <remarks>This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.</remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndDiscoverLocalHosts(uLink.HostDataFilter,System.Int32,System.Single)">
      <summary>
            Returns the latest host list discovered on the LAN and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <remarks>This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.</remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndDiscoverLocalHosts(System.String,System.Int32,System.Int32,System.Single)">
      <summary>
            Returns the latest host list discovered on the LAN and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <remarks>This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.</remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndDiscoverLocalHosts(uLink.HostDataFilter,System.Int32,System.Int32,System.Single)">
      <summary>
            Returns the latest host list discovered on the LAN and makes a new host list request 
            if the last request is older than requestInterval.
            </summary>
      <remarks>This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest host list and also make sure the list is refreshed with a specified interval.</remarks>
    </member>
    <member name="M:uLink.MasterServer.PollKnownHostData(System.String,System.Int32)">
      <summary>
            Gets the HostData info for one favorite servers (Known Hosts) stored in the client.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.PollKnownHostData(System.Net.IPEndPoint)">
      <summary>
            Gets the HostData info for one favorite servers (Known Hosts) stored in the client.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.RequestKnownHostData(System.String,System.Int32)">
      <summary>
            Requests the HostData info for one favorite servers (Known Hosts) stored in the client. Answer can be read with <see cref="O:PollKnownHostData" /></summary>
    </member>
    <member name="M:uLink.MasterServer.RequestKnownHostData(System.Net.IPEndPoint)">
      <summary>
            Requests the HostData info for one favorite servers (Known Hosts) stored in the client. Answer can be read with <see cref="O:PollKnownHostData" /></summary>
    </member>
    <member name="M:uLink.MasterServer.AddKnownHostData(System.String,System.Int32)">
      <summary>
            Store location info for a favorite server (Known Host) in the client.
            </summary>
      <remarks>
            It is possible to store a separate list of known hosts (favourite servers) in the local uLink client.
            Use the API for Known Host Data in this class to build a feature for your users to 
            store their favourite servers and access them easily
            when they try to reconnect to play the game again on the same server as before.
            </remarks>
    </member>
    <member name="M:uLink.MasterServer.RemoveKnownHostData(System.String,System.Int32)">
      <summary>
            Remove location info for a favorite server (Known Host) in the client.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.RemoveKnownHostData(System.Net.IPEndPoint)">
      <summary>
            Remove location info for a favorite server (Known Host) in the client.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.ClearKnownHosts">
      <summary>
            Clear all location info for all favorite servers (Known Hosts) in the client.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.PollKnownHosts">
      <summary>
            Gets the list with the most recent update of HostData information for all favorite servers (Known Hosts) stored in the client.
            </summary>
    </member>
    <member name="M:uLink.MasterServer.RequestKnownHosts">
      <summary>
            Request to make the complete list of Known Hosts available. 
            </summary>
      <remarks>
            The answer will be available via <see cref="M:uLink.MasterServer.PollKnownHosts" />.
            See also <see cref="M:uLink.MasterServer.PollAndRequestKnownHosts(System.Single)" /></remarks>
    </member>
    <member name="M:uLink.MasterServer.PollAndRequestKnownHosts(System.Single)">
      <summary>
            Gets the list with fresh HostData info for all favorite servers (Known Hosts) stored in the client.
            </summary>
      <remarks>This method is convenient to run in Update() in a client. This way you can write one code line to 
            always get the latest known host list and also make sure the list is refreshed with a specified interval.
            Values like <see cref="F:uLink.HostData.ping" /> and <see cref="F:uLink.LocalHostData.connectedPlayers" /> are refreshed.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.lastError">
      <summary>
            The last <see cref="T:uLink.NetworkConnectionError" /> returned by the master server. 
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkConnectionError.NoError" /></value>
    </member>
    <member name="P:uLink.MasterServer.dedicatedServer">
      <summary>
            Mark this server as a dedicated server (it is running without a human player). 
            </summary>
      <value>Default value is <c>false</c></value>
      <remarks>
            If running as a server, the connection count defines the player count
            and this is reported when registering on the master server. By
            default the master server assumes this server instance is not a dedicated
            server and thus the player count is incremented by one (to account
            for the "player" running the game server). If this is not desired, 
            for example when hosting servers in a data center,
            this variable can be set to <c>true</c> before registering game servers 
            and then only the client connection count
            is reported in the host data as the player count.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.ipAddress">
      <summary>
            The IP address of the master server. Can be the domain name or the IP number.
            </summary>
    </member>
    <member name="P:uLink.MasterServer.port">
      <summary>
            The connection port of the master server.
            </summary>
    </member>
    <member name="P:uLink.MasterServer.ping">
      <summary>
            Gets a rolling average roundtrip ping time, meassured between this client and the master server. 
            Returns 0 if there is no connection to the master server.
            </summary>
    </member>
    <member name="P:uLink.MasterServer.password">
      <summary>
            The password required to make a connection to the master server.
            </summary>
      <remarks>
            This password value, in a running master server, is set by the operator as 
            a start argument when starting the master server.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.isRegistered">
      <summary>
            Is this game server registered in the master server?
            </summary>
      <remarks>
            Use this in the game server, not in a client. Default value is <c>false</c>.
            </remarks>
    </member>
    <member name="P:uLink.MasterServer.updateRate">
      <summary>
            The minimum update rate for master server host information update. 
            </summary>
      <remarks>
            Normally host updates are only sent if something in the host
            information has changed (like connected players). The update rate
            defines the minimum amount of time which may elapse between host
            updates. The default value is 80 seconds minimum update rate (where
            a check is made for changes). So if one host update is sent and then
            some field changes 10 seconds later then the update will possibly be
            sent 70 seconds later (at the next change check). If this is set to
            0 then no updates are sent, only initial registration information. 
            </remarks>
      <example>
        <code>
            function StartServer() {
               Network.InitializeServer(32, 25002);
               // No host information updates after initial registration
               MasterServer.updateRate = 0;
               MasterServer.RegisterHost("MyUniqueGameType", "JohnDoes game", "l33t game for all");
            }
            </code>
      </example>
    </member>
    <member name="P:uLink.MasterServer.gameType">
      <summary>
            Gets or sets the gameType string for this game server.
            </summary>
    </member>
    <member name="P:uLink.MasterServer.gameName">
      <summary>
            Gets or sets the gameName string for this game server.
            </summary>
    </member>
    <member name="P:uLink.MasterServer.gameMode">
      <summary>
            Gets or sets the gameMode string for this game server.
            </summary>
    </member>
    <member name="P:uLink.MasterServer.gameLevel">
      <summary>
            Gets or sets the gameLevel string for this game server.
            </summary>
    </member>
    <member name="P:uLink.MasterServer.comment">
      <summary>
            Gets or sets the comment string for this game server.
            </summary>
    </member>
    <member name="T:uLink.NetworkP2PBase">
      <summary>
            Abstract base class for the class <see cref="T:uLink.NetworkP2P" />. 
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PBase.incomingPassword">
      <summary>
            Set this string to use a password check for incoming P2P connections. 
            </summary>
      <remarks>
            Default value for incomingPassword is an empty string. Then there is no password check when som other peer
            tries to conenct to this peer. But if this string is set, the password must be provided in 
            the connection request to this peer.</remarks>
    </member>
    <member name="F:uLink.NetworkP2PBase.lastError">
      <summary>
            Gets the last returned <see cref="T:uLink.NetworkConnectionError" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.GetStatus(uLink.NetworkPeer)">
      <summary>
            Gets the status of a remote node connected to this peer.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.CloseConnection(uLink.NetworkPeer,System.Boolean)">
      <summary>
            Closes the connection to a remote node.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.CloseConnection(uLink.NetworkPeer,System.Boolean,System.Int32)">
      <summary>
            Closes the connection to a remote node after the given timeout has expired
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.String,uLink.NetworkPeer,System.Object[])">
      <overloads>Sends an RPC from this P2P connection</overloads>
      <summary>
             Send an RPC to a remote node.
             </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Send an RPC to remote node(s) according to the specified PeerMode.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(uLink.NetworkFlags,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Send an RPC to one remote node.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(uLink.NetworkFlags,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Send an RPC to remote node(s) according to the specified <see cref="T:uLink.PeerMode" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(System.Type,uLink.NetworkFlags,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified Type (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(System.Type,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.PeerMode,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.RPCMode,System.Object[])" /></remarks>
    </member>
    <member name="M:uLink.NetworkP2PBase.RPC(UnityEngine.MonoBehaviour,uLink.NetworkFlags,System.String,uLink.NetworkPeer,System.Object[])">
      <summary>
            Sends an RPC restricted to the specified MonoBehavior (parameter type)
            </summary>
      <remarks>Works similar to <see cref="M:uLink.NetworkView.RPC(UnityEngine.MonoBehaviour,System.String,uLink.NetworkPlayer,System.Object[])" /></remarks>
    </member>
    <member name="P:uLink.NetworkP2PBase.isTypeSafeByDefault">
      <summary>
            Whether RPC:s sent over this connection should be type-safe or not by default.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.isListening">
      <summary>
            Whether this P2P node is listening for incoming connections or not.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.connections">
      <summary>
            Currently connected remote peers.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2PBase.allConnections">
      <summary>
            All current remote peers whether connected, connecting, disconnecting or recently disconnected.
            </summary>
    </member>
    <member name="T:uLink.NetworkStartEvent">
      <summary>
            The available types of network start events. See <see cref="!:uLink.Network.uLink_OnPreStartNetwork" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkStartEvent.MasterServer">
      <summary>
            A master server connection is about to be initilized
            </summary>
    </member>
    <member name="F:uLink.NetworkStartEvent.Server">
      <summary>
            The game server is about to be initilized
            </summary>
    </member>
    <member name="F:uLink.NetworkStartEvent.Client">
      <summary>
            A client is about to be initilized
            </summary>
    </member>
    <member name="F:uLink.NetworkStartEvent.CellServer">
      <summary>
            A cell server is about to be initilized
            </summary>
    </member>
    <member name="T:uLink.NetworkStatus">
      <summary>
            The available network statuses. See <see cref="P:uLink.Network.status" />. See also <see cref="P:uLink.Network.peerType" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkStatus.Disconnected">
      <summary>
            This peer is disconnected
            </summary>
    </member>
    <member name="F:uLink.NetworkStatus.Connecting">
      <summary>
            This peer is connecting
            </summary>
    </member>
    <member name="F:uLink.NetworkStatus.Connected">
      <summary>
            This peer is connected
            </summary>
    </member>
    <member name="F:uLink.NetworkStatus.Disconnecting">
      <summary>
            This peer is disconnecting
            </summary>
    </member>
    <member name="T:uLink.NetworkLogLevel">
      <summary>
            The available log levels that can be set for minimum uLink logging and also can be set per log category.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Off">
      <summary>
            Logs nothing.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Error">
      <summary>
            Logs errors only
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Warning">
      <summary>
            Logs warnings and errors.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Info">
      <summary>
            Logs info messages, warnings and errors.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Debug">
      <summary>
            Logs debug messages, info messages, warnings and errors. The most detailed log level available.
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Informational">
      <summary>
            Deprecated, please use NetworkLogLevel.Info instead
            </summary>
    </member>
    <member name="F:uLink.NetworkLogLevel.Full">
      <summary>
            Deprecated, please use NetworkLogLevel.Debug instead
            </summary>
    </member>
    <member name="T:uLink.NetworkLogFlags">
      <summary>
            The different log categories available in uLink. Read more in <see cref="T:uLink.NetworkLog" />.
            </summary>
    </member>
    <member name="T:uLink.NetworkRole">
      <summary>
            The role of a peer/host for a network aware object (created with <see cref="O:uLink.Network.Instantiate" />).
            </summary>
      <remarks>Read more in the manual about the three roles for network aware objects.</remarks>
    </member>
    <member name="F:uLink.NetworkRole.Disconnected">
      <summary>
            The peer/host is disconnected from the network.
            </summary>
    </member>
    <member name="F:uLink.NetworkRole.Proxy">
      <summary>
            This peer/host has a proxy of this network aware object.
            </summary>
    </member>
    <member name="F:uLink.NetworkRole.Owner">
      <summary>
            This peer/host is the owner of this network aware object.
            </summary>
    </member>
    <member name="F:uLink.NetworkRole.Creator">
      <summary>
            This peer/host is the creator of this network aware object.
            </summary>
    </member>
    <member name="T:uLink.NetworkFlags">
      <summary>
            Used to control how RPCs will be handled by uLink.
            </summary>
      <remarks>Turn on one or many the these bit flags to make uLink handle
            the RPC exactly the way you want it. The buffer flag argument will overrule
            the buffer setting that the <see cref="T:uLink.RPCMode" /> argument in the
            <see cref="M:uLink.NetworkView.RPC(uLink.NetworkFlags,System.String,uLink.RPCMode,System.Object[])" /> function 
            usually  controls. If they are conflicting, uLink  log a warning.</remarks>
    </member>
    <member name="F:uLink.NetworkFlags.Normal">
      <summary>
            This is the base value. The RPC will be reliable, buffered, encrypted, typesafe and include a timestamp.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.Unreliable">
      <summary>
            The RPC is sent over an unreliable network channel in uLink. Default is OFF.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.Unbuffered">
      <summary>
            The RPC is not stored in the RPC buffer on the server. This flag
            overrules the <see cref="T:uLink.RPCMode" /> buffer setting. Default Value is OFF.
            </summary>
      <value>
      </value>
    </member>
    <member name="F:uLink.NetworkFlags.Unencrypted">
      <summary>
            The RPC is never encrypted, even if sequrity is turned on. Default value is OFF.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.NoTimestamp">
      <summary>
            The RPC has no timestamp (to save bandwidth). Default value is OFF.
            </summary>
    </member>
    <member name="F:uLink.NetworkFlags.TypeUnsafe">
      <summary>
            The types of the arguments in the RPC will not be checked when this RPC is received. Default value is OFF.
            </summary>
    </member>
    <member name="T:uLink.NetworkStateSynchronization">
      <summary>
            The supported state synchronization modes for network aware objects in uLink
            </summary>
    </member>
    <member name="F:uLink.NetworkStateSynchronization.Off">
      <summary>
            This NetworkView will not send any statesync traffic
            </summary>
    </member>
    <member name="F:uLink.NetworkStateSynchronization.Unreliable">
      <summary>
            The statesync traffic will be unreliable (uses least server side resources, but some packets can be lost in the network).
            </summary>
    </member>
    <member name="F:uLink.NetworkStateSynchronization.Reliable">
      <summary>
            The statesync traffic will be reliable (all packets will arrive at destination).
            </summary>
    </member>
    <member name="F:uLink.NetworkStateSynchronization.ReliableDeltaCompressed">
      <summary>
            The statesync traffic will be reliable and delta compressed (to save bandwidth).
            </summary>
    </member>
    <member name="T:uLink.NetworkSecurable">
      <summary>
            The available choices for property "Securable" in a uLinkNetworkView component. 
            </summary>
    </member>
    <member name="T:uLink.NetworkDisconnection">
      <summary>
            The available reasons for a disconnection event in uLink. 
            </summary>
      <remarks>See uLink.Network.<see cref="!:uLink.Network.uLink_OnDisconnectedFromServer" /></remarks>
    </member>
    <member name="T:uLink.PeerMode">
      <summary>
            The available modes for sending RPCs in a peer-to-peer network.
            </summary>
      <remarks>see <see cref="T:uLink.NetworkP2P" /></remarks>
    </member>
    <member name="F:uLink.PeerMode.Others">
      <summary>
            Send the RPC to all peers except myself.
            </summary>
    </member>
    <member name="F:uLink.PeerMode.All">
      <summary>
            Send the RPC to all peers including myself.
            </summary>
    </member>
    <member name="T:uLink.RPCMode">
      <summary>
            Indicates how a RPC should be treated by uLink.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.Server">
      <summary>
            The RPC will only be sent to the server. This is the only allowed RPCMode in clients when the server is authoritative.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.Others">
      <summary>
            The RPC will be sent to every connected peer and I will not get the RPC myself.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.All">
      <summary>
            The RPC will be sent to every connected peer, including myself.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.Owner">
      <summary>
            The RPC will only be sent to the owner of the network aware object.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.Buffered">
      <summary>
            The RPC will only be added to RPC buffer, which is sent to new players when their connection is established.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.OthersBuffered">
      <summary>
            The RPC will be sent to every connected peer and I will not get the RPC myself. The server will also buffer this RPC.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.AllBuffered">
      <summary>
            The RPC will be sent to every connected peer, including myself. The server will also buffer this RPC.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.OthersExceptOwner">
      <summary>
            The RPC will be sent to every connected peer, but not to myself and not to the owner of the network aware object.
            </summary>
    </member>
    <member name="F:uLink.RPCMode.AllExceptOwner">
      <summary>
            The RPC will be sent to every connected peer, but not to the owner of the network aware object.
            </summary>
    </member>
    <member name="T:uLink.NetworkPeerType">
      <summary>
            A peer can be only one of these types. See <see cref="P:uLink.Network.peerType" />. See also <see cref="P:uLink.Network.status" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkPeerType.Disconnected">
      <summary>
            The peer is disconnected
            </summary>
    </member>
    <member name="F:uLink.NetworkPeerType.Server">
      <summary>
            The peer is a server
            </summary>
    </member>
    <member name="F:uLink.NetworkPeerType.Client">
      <summary>
            The peer is a client
            </summary>
    </member>
    <member name="F:uLink.NetworkPeerType.CellServer">
      <summary>
            This peer is a cellserver
            </summary>
    </member>
    <member name="T:uLink.NetworkConnectionError">
      <summary>
            The available connection errors in uLink.
            </summary>
      <remarks>Use the value UserDefined1 for signaling your own custom error situation to the client.
            Send this error code from the server code you write for the the callback 
            <see cref="!:uLink.Network.uLink_OnPlayerApproval" />.
            If you need more custom error codes, just add the integers 1, 2, 3 and so on.
            </remarks>
      <example>
            Define your own error codes like this in a script the server and the clients can both access.
            <code>
            public int MyErrorCode1 = uLink.NetworkConnectionError.UserDefined1;
            public int MyErrorCode2 = uLink.NetworkConnectionError.UserDefined1 + 1;
            public int MyErrorCode3 = uLink.NetworkConnectionError.UserDefined1 + 2;
            </code></example>
    </member>
    <member name="T:uLink.ConnectionTesterStatus">
      <summary>
            The available return values when testing a network connection's NAT
            capabilities.
            </summary>
      <remarks>
            See <see cref="O:uLink.Network.TestConnection" />
            and <see cref="M:uLink.Network.TestConnectionNAT" />.
            </remarks>
    </member>
    <member name="T:uLink.MasterServerEvent">
      <summary>
            The available response codes when communicating with a stand-alone <see cref="T:uLink.MasterServer" />.
            </summary>
    </member>
    <member name="T:uLink.BitStreamTypeCode">
      <summary>
            The data types uLink can Serialize. Read more about this in the manual section for data types and serialization.
            </summary>
    </member>
    <member name="T:uLink.NetworkLogUtility">
      <summary>
            Utility class for composing log messages.
            </summary>
    </member>
    <member name="T:uLink.HostDataFilter">
      <summary>
            Used to filter the list of servers in a MasterServer.
            </summary>
    </member>
    <member name="T:uLink.HostDataFilter.RelationFlags">
      <summary>
            To set conditions like "connected players must be more than 0 players" or "player limit less or equal to 10". 
            </summary>
    </member>
    <member name="T:uLink.HostDataFilter.Relation">
      <summary>
            Defines relation conditions.
            </summary>
    </member>
    <member name="T:uLink.PeerDataFilter">
      <summary>
            Used to filter the list of servers in a MasterServer.
            </summary>
    </member>
    <member name="T:uLink.RegisterPrefabs">
      <summary>
             Use this script component to register the prefabs that will be
             used in <see cref="O:uLink.Network.Instantiate" />. 
            
             If all your prefabs are placed in the Resources folder, there is no need to use this
             utility script. 
            
             If you want to register prefabs at run-time, for example after downloading an asset 
             bundle in a client, check out <see cref="T:uLink.NetworkInstantiator" /> in the API doc.
            
             Read more about registering prefabs in the manual chapter about Instantiating Objects.
             </summary>
    </member>
    <member name="T:uLink.NetworkObserved">
      <summary>
            Helper class for caching and binding. 
            </summary>
      <remarks>This class is used internally in uLink, but it is made public to be used in some custom cases.</remarks>
    </member>
    <member name="F:uLink.NetworkObserved.defaultBinder">
      <summary>
            Used when no custom binder has been set.
            </summary>
    </member>
    <member name="M:uLink.NetworkObserved.#ctor(UnityEngine.Component)">
      <summary>
            Use this constructor. Send your component as argument.
            </summary>
      <param name="component">The component.</param>
    </member>
    <member name="M:uLink.NetworkObserved.CreateSerializer(System.Object,System.Type,System.String)">
      <summary>
            This is a help function for creating a custom binder.
            </summary>
      <param name="obj">The obj.</param>
      <param name="type">The type.</param>
      <param name="name">The name.</param>
      <returns>
      </returns>
    </member>
    <member name="T:uLink.NetworkObserved.Binder">
      <summary>
            Has the responsibility to assign each serializer member of NetworkObserved to an approriate delegate.
            </summary>
    </member>
    <member name="T:uLink.NetworkObserved.Serializer">
      <summary>
            Callback that gets called to serialize a specific state. 
            </summary>
      <remarks>For example uLink_OnSerializeNetworkView, uLink_OnSerializeNetworkViewOwner, uLink_OnHandoverNetworkView.</remarks>
    </member>
    <member name="M:uLink.NetworkInstantiatorUtility.GetComponentsInChildren``1(UnityEngine.Transform)">
      <summary>
            This function is a replacement for Unity's regular GetComponentsInChildren, which also works on prefabs.
            </summary>
    </member>
    <member name="M:uLink.NetworkInstantiatorUtility.SetActiveRecursively(UnityEngine.Transform,System.Boolean)">
      <summary>
            This function is a replacement for Unity's regular SetActiveRecursively, which also works on prefabs.
            </summary>
    </member>
    <member name="T:uLink.NetworkLog">
      <summary>
             Class for configuring uLink logging.
             </summary>
      <remarks>
             The best way to get started with logging in uLink is to use the Editor menu: uLink - Edit Settings. 
             There it is possbile to configure logging level per category and use the generated output to debug most problems.
             By default the log messages are written to the Unity console window in the editor or the log file output_log.txt when 
             running a build outside the editor.
             <para>
             Use this class to go one step further and control the log settings in your own code. Also use it to 
             replace the 4 public Writers with your own faster implementations: 
             <see cref="F:uLink.NetworkLog.errorWriter" />, <see cref="F:uLink.NetworkLog.warningWriter" />, <see cref="F:uLink.NetworkLog.infoWriter" />, <see cref="F:uLink.NetworkLog.debugWriter" /> 
             with your own implementations it is possible to log events to 
             screen or file(s) or database or whatever you like. 
             </para><para>
             Finally, it is possible to add your own logging categories like “Trading”, “Cheating attempts” or “Level loding” 
             and set the log level individually for these categories.
             </para></remarks>
      <example> 
             This example shows how to create and use your own log categories:
             <code>
             using UnityEngine;
             using System.Collections;
             public class CustomLog : MonoBehaviour 
             {
                //Define your own log categories like this
                public const uLink.NetworkLogFlags CHEAT_ATTEMPTS = uLink.NetworkLogFlags.UserDefined1;
                public const uLink.NetworkLogFlags TRADE_EVENT = uLink.NetworkLogFlags.UserDefined2;
                public const uLink.NetworkLogFlags LEVEL_LOAD_EVENT = uLink.NetworkLogFlags.UserDefined3;
            
                void Start()
                {
                    //Set the log level for cheat attempts to the highest = Debug    
                    uLink.NetworkLog.SetLevel(CHEAT_ATTEMPTS, uLink.NetworkLogLevel.Debug);
            
                    //Do some debug logging
                    for (int i = 1; i != 5; i++)
                    {
                        uLink.NetworkLog.Debug(CHEAT_ATTEMPTS, "Detected cheat attempt nr ", i, " in the demo code.");
                    }
                }
             }
             </code></example>
    </member>
    <member name="F:uLink.NetworkLog.errorWriter">
      <summary>
            The delegate writing error messages. Default implementation send output to the Editor console / output_log.txt file. 
            </summary>
      <remarks>Look at <see cref="T:uLink.NetworkLog.Writer" /> for code example replacing the default Writer.</remarks>
    </member>
    <member name="F:uLink.NetworkLog.warningWriter">
      <summary>
            The delegate writing warning messages. Default implementation send output to the Editor console / output_log.txt file. 
            </summary>
      <remarks>Look at <see cref="T:uLink.NetworkLog.Writer" /> for code example replacing the default Writer.</remarks>
    </member>
    <member name="F:uLink.NetworkLog.infoWriter">
      <summary>
            The delegate writing info messages. Default implementation send output to the Editor console / output_log.txt file. 
            </summary>
      <remarks>Look at <see cref="T:uLink.NetworkLog.Writer" /> for code example replacing the default Writer.</remarks>
    </member>
    <member name="F:uLink.NetworkLog.debugWriter">
      <summary>
            The delegate writing debug messages. Default implementation send output to the Editor console / output_log.txt file. 
            </summary>
      <remarks>Look at <see cref="T:uLink.NetworkLog.Writer" /> for code example replacing the default Writer.</remarks>
    </member>
    <member name="F:uLink.NetworkLog.minLevel">
      <summary>
            The minimum level for all logging categories. This can be overruled by setting a detailed log level for an individual category to a higher log level via <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" />.
            </summary>
      <value>Default value is <see cref="F:uLink.NetworkLogLevel.Warning" /></value>
    </member>
    <member name="M:uLink.NetworkLog.Debug(uLink.NetworkLogFlags,System.Object[])">
      <summary>
            Sends a log message to the delegate <see cref="F:uLink.NetworkLog.debugWriter" /> if the <see cref="F:uLink.NetworkLogLevel.Debug" /> log level for the specifed categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
      <param name="flags">The categories this log message belongs to</param>
      <param name="args">The objects that are to be concatenated to a log message if the debug log level for the flags is set</param>
      <example>Example code for writing a message like "The server has now received 88 Fire RPCs from player Paul55".
            <code>
            uLink.NetworkLog.Debug(uLink.NetworkLogFlags.Server, "The server has now received ", numberOfFireRPCs, " Fire RPCs from player ", playerName);
            </code></example>
      <remarks>Please note that it is important to NOT use string concatenation with + to compose the log message. 
            Instead send the objects individually just like the example code provided here. 
            Otherwise you will lose performace. The concatenation would be executed even if the log level for the flags are 
            turned off, and that is a waste of CPU resources.</remarks>
    </member>
    <member name="M:uLink.NetworkLog.Info(uLink.NetworkLogFlags,System.Object[])">
      <summary>
            Sends a log message to the delegate <see cref="F:uLink.NetworkLog.infoWriter" /> if the <see cref="F:uLink.NetworkLogLevel.Info" /> log level for the specifed categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
      <param name="flags">The categories this log message belongs to</param>
      <param name="args">The objects that are to be concatenated to a log message if the info log level for the flags is set</param>
      <example>Example code for writing a message like "The server has now received 88 Fire RPCs from player Paul55".
            <code>
            uLink.NetworkLog.Info(uLink.NetworkLogFlags.Server, "The server has now received ", numberOfFireRPCs, " Fire RPCs from player ", playerName);
            </code></example>
      <remarks>Please note that it is important NOT to use string concatenation with + to compose a nice log message. 
            Instead send the arguments individually just like the example code provided here. 
            Otherwise you will lose performace. The concatenation would be executed even if the logging 
            is turned off, and that is a waste of CPU resources.</remarks>
    </member>
    <member name="M:uLink.NetworkLog.Warning(uLink.NetworkLogFlags,System.Object[])">
      <summary>
            Sends a log message to the delegate <see cref="F:uLink.NetworkLog.warningWriter" /> if the <see cref="F:uLink.NetworkLogLevel.Warning" /> log level for the specifed categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
      <param name="flags">The categories this log message belongs to</param>
      <param name="args">The objects that are to be concatenated to a log message if the info log level for the flags is set</param>
      <example>Example code for writing a message like "The server has now received 88 Fire RPCs from player Paul55".
            <code>
            uLink.NetworkLog.Warning(uLink.NetworkLogFlags.Server, "The server has now received ", numberOfFireRPCs, " Fire RPCs from player ", playerName);
            </code></example>
      <remarks>Please note that it is important NOT to use string concatenation with + to compose a nice log message. 
            Instead send the arguments individually just like the example code provided here. 
            Otherwise you will lose performace. The concatenation would be executed even if the logging 
            is turned off, and that is a waste of CPU resources.</remarks>
    </member>
    <member name="M:uLink.NetworkLog.Error(uLink.NetworkLogFlags,System.Object[])">
      <summary>
            Sends a log message to the delegate <see cref="F:uLink.NetworkLog.errorWriter" /> if the <see cref="F:uLink.NetworkLogLevel.Error" /> log level for the specifed categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
      <param name="flags">The categories this log message belongs to</param>
      <param name="args">The objects that are to be concatenated to a log message if the info log level for the flags is set</param>
      <example>Example code for writing a message like "The server received an illegal Fire RPCs from player Paul55".
            <code>
            uLink.NetworkLog.Error(uLink.NetworkLogFlags.Server, "The server received an illegal Fire RPCs from player ", playerName);
            </code></example>
      <remarks>Please note that it is important NOT to use string concatenation with + to compose a nice log message. 
            Instead send the arguments individually just like the example code provided here. 
            Otherwise you will lose performace. The concatenation would be executed even if the logging 
            is turned off, and that is a waste of CPU resources.</remarks>
    </member>
    <member name="M:uLink.NetworkLog.HasLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)">
      <summary>
            Returns true if the the categories (flags) are set by either <see cref="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)" /> or <see cref="F:uLink.NetworkLog.minLevel" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags,uLink.NetworkLogLevel)">
      <summary>
            Sets a detailed logging level for the specified categories (flags). If the categories (flags) is set to a lower log level than <see cref="F:uLink.NetworkLog.minLevel" /> then <see cref="F:uLink.NetworkLog.minLevel" /> overrules the detailed log level when logging.
            </summary>
    </member>
    <member name="M:uLink.NetworkLog.GetMaxLevel(uLink.NetworkLogFlags)">
      <summary>
            Gets the highest detailed log level configured for any of the log categories (flags), where 
            <see cref="F:uLink.NetworkLogLevel.Off" /> is the lowest and <see cref="F:uLink.NetworkLogLevel.Debug" /> is the highest.
            </summary>
    </member>
    <member name="M:uLink.NetworkLog.GetMinLevel(uLink.NetworkLogFlags)">
      <summary>
            Gets the lowest detailed log level configured for any of the log categories (flags), where 
            <see cref="F:uLink.NetworkLogLevel.Off" /> is the lowest and <see cref="F:uLink.NetworkLogLevel.Debug" /> is the highest.
            </summary>
    </member>
    <member name="P:uLink.NetworkLog.errorFlags">
      <summary>
            Gets or sets the log categories for the <see cref="F:uLink.NetworkLog.errorWriter" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkLog.warningFlags">
      <summary>
            Gets or sets the log categories for the <see cref="F:uLink.NetworkLog.warningWriter" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkLog.infoFlags">
      <summary>
            Gets or sets the log categories for the <see cref="F:uLink.NetworkLog.infoWriter" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkLog.debugFlags">
      <summary>
            Gets or sets the log categories for the <see cref="F:uLink.NetworkLog.debugWriter" />.
            </summary>
    </member>
    <member name="T:uLink.NetworkLog.Writer">
      <summary>
            Implement one or several new delegates if there is a need to replace the default Writers in this class. 
            </summary>
      <example>
            In your own implementation you can choose another destination for log messages. 
            This example code shows how to send log messages to a file.
            <code>
            using UnityEngine;
            using System.Collections;
            using System.IO;
            
            public class CustomFileLog : MonoBehaviour 
            {
                public string logFileName = @"c:\temp\MyLog.txt";
            
                void Start()
                {
                    //This code replaces the default debugWriter with a new delegate
                    uLink.NetworkLog.debugWriter = delegate(uLink.NetworkLogFlags flags, object[] args) 
                    {
                        string line = System.DateTime.Now + ", " + uLink.NetworkLogUtility.ToString(args) + "\r\n";
                        File.AppendAllText(logFileName, line); 
                    };
            
                    //Set the level to Debug for the category uLink.NetworkLogFlags.Server
                    uLink.NetworkLog.SetLevel(uLink.NetworkLogFlags.Server, uLink.NetworkLogLevel.Debug);
            
                    //Do some debug logging to the file
                    for (int i = 1; i != 5; i++)
                    {
                        uLink.NetworkLog.Debug(uLink.NetworkLogFlags.Server, "Hello ", i, " from demo code.");
                    }
                }
            }
            </code></example>
    </member>
    <member name="T:uLink.NetworkP2PMessageInfo">
      <summary>
            A class containing some extra information about the sender of this network P2P message.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PMessageInfo.sender">
      <summary>
            The <see cref="T:uLink.NetworkPeer" /> who sent the message.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PMessageInfo.flags">
      <summary>
            The flags used when sending this message.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2PMessageInfo.networkP2P">
      <summary>
            The <see cref="T:uLink.NetworkP2P" /> this message was sent from.
            </summary>
    </member>
    <member name="T:uLink.LocalPeerData">
      <summary>
            Base data structure for holding individual host (server) information, for a LAN server without an external IP address.
            </summary>
      <remarks>
            Host information for servers with and external public address is stored in the subclass <see cref="T:uLink.HostData" />.
            </remarks>
    </member>
    <member name="F:uLink.LocalPeerData.peerType">
      <summary>
            The type of the game (like MyUniqueGameType).
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.peerName">
      <summary>
            The name of the game (like John Doe's Game)
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.passwordProtected">
      <summary>
            Does the server require a password?
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.comment">
      <summary>
            A miscellaneous comment about the server
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.platform">
      <summary>
            Use this string to describe the platform needed for connecting to this game server.
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.timestamp">
      <summary>
            The time when this data (about the host) was collected.
            </summary>
    </member>
    <member name="F:uLink.LocalPeerData.internalEndpoint">
      <summary>
            The IP address and port for this host in the local network (LAN). 
            </summary>
    </member>
    <member name="M:uLink.LocalPeerData.IsDefined">
      <summary>
            Returns true if internalEnpoint, gameType and gameName has been set, otherwise false.
            </summary>
    </member>
    <member name="P:uLink.LocalPeerData.internalPort">
      <summary>
            Server private port in the local network (LAN). 
            </summary>
    </member>
    <member name="P:uLink.LocalPeerData.internalIP">
      <summary>
            Server private IP address in the local network (LAN). 
            </summary>
    </member>
    <member name="T:uLink.NetworkPlayerApproval">
      <summary>
            The request data sent from a client wanting to connect to a server.
            </summary>
      <remarks>
            See <see cref="!:uLink.Network.uLink_OnPlayerApproval" /></remarks>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.loginData">
      <summary>
            The Bitstream containing the loginData sent from the client.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.localData">
      <summary>
            Set value for <see cref="P:uLink.NetworkPlayer.localData" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.handoverInstances">
      <summary>
            If the client has been handed over from a another server, then instances are the player's handover prefabs set by that server, otherwise empty.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayerApproval.handoverData">
      <summary>
            If the client has been handed over from a another server, then handoverData can be set by that server, otherwise null.
            </summary>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.Approve(System.Object[])">
      <summary>
            Approves the client. A connection response will be sent internally by uLink to the client.
            </summary>
      <param name="approvalData">The approval data that will be delivered to the client.</param>
      <exception cref="T:System.ArgumentNullException">when approvalData is null or one of the arguments is null.</exception>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.AssignManualPlayerID(System.Int32)">
      <summary>
            Assigns a custom unique player ID to this player instead of using the
            unique player ID that uLink would have provided automatically.
            </summary>
      <remarks>The main purpose of using this function would be to set the
            player ID to the same player ID you have in a persistent storage
            like a database. If your player IDs are integers and they are
            limited to the same range  as the uLink internal protocol (which is
            1 to <see cref="F:System.UInt16.MaxValue" /> - 1) it is very convenient to use
            these IDs from the database directly as playerIDs in uLink. 0 is
            reserved for unassigned clients and <see cref="F:System.UInt16.MaxValue" /> is
            reserved for representing the server. If you have another data type
            or a bigger integer range for unique player IDs in your database 
            this feature can not be used. Instead you have to store the database
            userID in one of the player's game objects on the server.
            </remarks>
      <exception cref="T:uLink.NetworkException">If trying to assign a manual playerID during a P2P handover.</exception>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.Deny">
      <summary>
            Denies the player to connect and sends a reason code to the client.
            </summary>
    </member>
    <member name="M:uLink.NetworkPlayerApproval.Deny(uLink.NetworkConnectionError)">
      <summary>
            Denies the player to connect and sends a reason code to the client.
            </summary>
      <param name="reason">The reason for not being granted a connection the player will get as a parameter in the 
            callback <see cref="!:uLink.Network.uLink_OnFailedToConnect" /></param>
    </member>
    <member name="T:uLink.NetworkUtility">
      <summary>
            Utility class for handling hostnames and IP addresses.
            </summary>
    </member>
    <member name="M:uLink.NetworkUtility.GetLocalAddresses">
      <summary>
            Gets my local IP address (not necessarily external) and subnet mask
            </summary>
    </member>
    <member name="M:uLink.NetworkUtility.IsPublicAddress(System.Net.IPEndPoint)">
      <summary>
            Returns true if the IPEndPoint supplied is a public IP address
            </summary>
      <remarks>
            An IP address is considered public if the IP number is valid and falls outside any of the IP address ranges reserved for private uses by Internet standards groups.
            Private IP addresses are typically used on local networks including home, school and business LANs including airports and hotels.
            </remarks>
    </member>
    <member name="M:uLink.NetworkUtility.IsPublicAddress(System.Net.IPAddress)">
      <summary>
            Returns true if the IPAddress supplied is a public IP address
            </summary>
      <remarks>
            An IP address is considered public if the IP number is valid and falls outside any of the IP address ranges reserved for private uses by Internet standards groups.
            Private IP addresses are typically used on local networks including home, school and business LANs including airports and hotels.
            </remarks>
    </member>
    <member name="T:uLink.NetworkAddressInfo">
      <summary>
            Represents an IP address plus mask
            </summary>
    </member>
    <member name="T:uLink.NetworkMessageInfo">
      <summary>
            A class containing some extra information about the sender of this network message.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.sender">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> who sent the message.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.timestampInMillis">
      <summary>
            The time (milliseconds) when the message was sent. See also uLink.Network.<see cref="P:uLink.Network.timeInMillis" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.networkView">
      <summary>
            The <see cref="T:uLink.NetworkView" /> this message was sent from.
            </summary>
    </member>
    <member name="F:uLink.NetworkMessageInfo.flags">
      <summary>
            The flags used when sending this message.
            </summary>
    </member>
    <member name="P:uLink.NetworkMessageInfo.timestamp">
      <summary>
            The time (seconds) when the message was sent. See also uLink.Network.<see cref="P:uLink.Network.time" />.
            </summary>
    </member>
    <member name="T:uLink.NetworkViewID">
      <summary>
            The NetworkViewID is a unique identifier for a network view instance in a multiplayer game.
            </summary>
      <remarks>
            It is important that this is unique for every network aware object across all connected peers, or 
            else RPCs and statesyncs can be sent to the wrong object. 
            </remarks>
    </member>
    <member name="F:uLink.NetworkViewID.unassigned">
      <summary>
            Represents an invalid network view ID.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewID.max">
      <summary>
            Maximum <see cref="P:uLink.NetworkViewID.id" /> value a assigned viewID can have.
            </summary>
    </member>
    <member name="F:uLink.NetworkViewID.min">
      <summary>
            Minimum <see cref="P:uLink.NetworkViewID.id" /> value a assigned viewID can have.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:uLink.NetworkViewID" /> struct.
            </summary>
      <remarks>Never use this unless you know what you are doing. New instances should be created automatically by uLink.
            For example when calling the uLink.Network.
            <see cref="M:uLink.Network.Instantiate(UnityEngine.GameObject,UnityEngine.Vector3,UnityEngine.Quaternion,uLink.NetworkGroup,System.Object[])" />
            function</remarks>
    </member>
    <member name="M:uLink.NetworkViewID.op_Equality(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkViewID" />s are identical
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_Inequality(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if two <see cref="T:uLink.NetworkViewID" />s are not identical
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_GreaterThanOrEqual(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkViewID" /> is greater than or equal to the right <see cref="T:uLink.NetworkViewID" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_LessThanOrEqual(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkViewID" /> is less than or equal to the right <see cref="T:uLink.NetworkViewID" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_GreaterThan(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkViewID" /> is greater than the right <see cref="T:uLink.NetworkViewID" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.op_LessThan(uLink.NetworkViewID,uLink.NetworkViewID)">
      <summary>
            Returns <c>true</c> if the left <see cref="T:uLink.NetworkViewID" /> is less than the right <see cref="T:uLink.NetworkViewID" />.
            </summary>
    </member>
    <member name="M:uLink.NetworkViewID.GetHashCode">
      <summary>
            Returns the hash code for this <see cref="T:uLink.NetworkViewID" />.
            </summary>
      <returns>
            A 32-bit signed integer that is the hash code for this <see cref="T:uLink.NetworkViewID" />.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkViewID.Equals(System.Object)">
      <summary>
            Indicates whether this <see cref="T:uLink.NetworkViewID" /> and a specified object are equal.
            </summary>
      <returns>
        <c>true</c> if <paramref name="other" /> and this <see cref="T:uLink.NetworkViewID" /> are the same type and represent the same value; otherwise, <c>false</c>.
            </returns>
      <param name="other">Another object to compare to. </param>
      <filterpriority>2</filterpriority>
    </member>
    <member name="M:uLink.NetworkViewID.CompareTo(uLink.NetworkViewID)">
      <summary>
            Compares this instance with another specified <see cref="T:uLink.NetworkViewID" /> object and indicates
            whether this instance precedes, follows, or appears in the same position
            in the sort order as the specified <see cref="T:uLink.NetworkViewID" />.
            </summary>
      <param name="other">The other <see cref="T:uLink.NetworkViewID" />.</param>
      <returns>
            A 32-bit signed integer that indicates whether this instance precedes, follows,
            or appears in the same position in the sort order as the value parameter.
            </returns>
    </member>
    <member name="M:uLink.NetworkViewID.ToString">
      <summary>
            Returns a formatted string with details on this <see cref="T:uLink.NetworkViewID" />.
            </summary>
      <returns>
            A <see cref="T:System.String" /> containing a fully qualified type name.
            </returns>
      <filterpriority>2</filterpriority>
    </member>
    <member name="P:uLink.NetworkViewID.id">
      <summary>
            This is the unique ID number for this networkView.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewID.owner">
      <summary>
            The <see cref="T:uLink.NetworkPlayer" /> who owns the <see cref="T:uLink.NetworkView" />. Can be the server.
            </summary>
    </member>
    <member name="P:uLink.NetworkViewID.isMine">
      <summary>
            Gets a value indicating whether the <see cref="T:uLink.NetworkView" /> was instantiated by me.
            </summary>
      <value>
        <c>true</c> if instantiated by me; otherwise, <c>false</c>.</value>
    </member>
    <member name="P:uLink.NetworkViewID.isManual">
      <summary>
            Gets a value indicating whether this <see cref="T:uLink.NetworkView" /> was set in the Unity editor and (and the value is lower than than Network.maxManualViewIDs)
            </summary>
    </member>
    <member name="P:uLink.NetworkViewID.isAllocated">
      <summary>
            Gets a value indicating whether this <see cref="T:uLink.NetworkView" /> was allocated at runtime (and the value is higher than Network.maxManualViewIDs)
            </summary>
    </member>
    <member name="T:uLink.NetworkPlayer">
      <summary>
            This struct represents a client/player or the server.
            </summary>
      <remarks>The server is always represented by the static field 
            <see cref="F:uLink.NetworkPlayer.server" /></remarks>
    </member>
    <member name="F:uLink.NetworkPlayer.unassigned">
      <summary>
            Returned when calling uLink.Network.<see cref="P:uLink.Network.player" /> before the network has been initialized.
            See <see cref="O:uLink.Network.InitializeServer" /> and <see cref="M:uLink.Network.Connect(System.Net.IPEndPoint)" />.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.server">
      <summary>
            Returned when calling uLink.Network.<see cref="P:uLink.Network.player" /> on the server.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.maxClient">
      <summary>
            Maximum <see cref="P:uLink.NetworkPlayer.id" /> value a assigned client can have.
            </summary>
    </member>
    <member name="F:uLink.NetworkPlayer.minClient">
      <summary>
            Minimum <see cref="P:uLink.NetworkPlayer.id" /> value a assigned client can have.
            </summary>
    </member>
    <member name="M:uLink.NetworkPlayer.#ctor(System.Int32)">
      <summary>
            Initializes a new instance of the <see cref="T:uLink.NetworkPlayer" /> struct.
            </summary>
      <param name="id">The id. Minimum is 1 and maximum is UInt16.MaxValue.</param>
    </member>
    <member name="P:uLink.NetworkPlayer.id">
      <summary>
            Gets the unique id number for this player.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isServer">
      <summary>
            Gets a value indicating whether this instance is server.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isClient">
      <summary>
            Gets a value indicating whether this instance is client.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.isConnected">
      <summary>
            Gets a value indicating whether this instance is connected to the network.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.hasSecurity">
      <summary>
            Gets a value indicating whether this player (or server) has security turned on.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.statistics">
      <summary>
            Gets the <see cref="T:uLink.NetworkStatistics" /> for this player, which can be used to get connection statistics, bandwidth, packet counts etc.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.lastPing">
      <summary>
            Gets last ping time for a player in milliseconds.
            </summary>
      <returns>Last ping time for a player in milliseconds. If target is unknown or not connected, then returns -1.</returns>
      <remarks>In the client you should only call <c>uLink.NetworkPlayer.server.lastPing</c> because the only available target 
            is the server. In the server you can check the ping time for any connected player.
            </remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.averagePing">
      <summary>
            Gets average ping time for this player in milliseconds.
            </summary>
      <returns>Average ping time for a player in milliseconds. If target is unknown or not connected, then returns -1.</returns>
      <remarks>Calculates the average of the last few pings, making this a moving average.
            In the client you should only call <c>uLink.NetworkPlayer.server.averagePing</c> because the only available target 
            is the server. In the server you can check the ping time for any connected player.
            </remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.loginData">
      <summary>
            Gets the loginData sent by the player when the player connected.
            </summary>
      <remarks>
            Use this to get the loginData for any player on the server. When a player connects, the player can send extra 
            parameters in the <see cref="M:uLink.Network.Connect(uLink.HostData,System.String,System.Object[])" /> method 
            arguments. These parameter will be stored in the client and sent from the client. These parameters are received by 
            the server as loginData and stored in the server for the complete game 
            session (until the player disconnects) and can be retrieved this way on the server. 
            In a client the only available login data is your own loginData, sent using the 
            one of the <see cref="M:uLink.Network.Connect(uLink.HostData,System.String,System.Object[])" /> methods.
            </remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.endpoint">
      <summary>
            Returns the <see cref="T:System.Net.IPEndPoint" /> for this <see cref="T:uLink.NetworkPlayer" />.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.ipAddress">
      <summary>
            Gets the ip address for this NetworkPlayer.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.port">
      <summary>
            Gets the UDP port for this NetworkPlayer.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.externalIP">
      <summary>
            Gets the external IP for this NetworkPlayer.
            </summary>
      <remarks>The external IP for a client is usually the IP for the NAT-capable firewall/router this client 
            is placed behind.</remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.externalPort">
      <summary>
            Gets the external port for this NetworkPlayer.
            </summary>
      <remarks>The external port for a client is usually the port chosen by 
            the NAT-capable firewall/router this client is placed behind.</remarks>
    </member>
    <member name="P:uLink.NetworkPlayer.guid">
      <summary>
            Gets a unique ID for this player.
            </summary>
    </member>
    <member name="P:uLink.NetworkPlayer.localData">
      <summary>
            Gets or sets the localData, data that is not sent over the network.
            </summary>
      <remarks>
            Use this to store any kind of data for this player, data that should be stored locally only.
            This data will never be sent over the network. 
            Usually this is used on the server side for storing things per player. This could be 
            things like original spawn point, login time, cached data from the database, and whatever you like.
            The alternative is to set up one or several Dictionaries on the server for 
            storing data per player.
            </remarks>
    </member>
    <member name="T:uLinkExtensions">
      <summary>
            Special class to make some uLink features available in all GameObjects in Unity. Do not use this class directly.
            </summary>
      <remarks>
            This class uses new .Net features to add static methods to other classes. Therefore this feature is only available
            in Unity 3.0 and newer versions of Unity. The static methods this class adds are uLinkNetworkView() and 
            uLinkNetworkP2P() that can be accessed from 
            ALL GameObjects and Components in your code. The property will be <c>null</c> if no component of that type is
            attached to the GameObject. Do not use this class directly, see example below instead.
            </remarks>
      <example>
            This code works in C# only, in a script component.
            <code>
            //Using the game object
            Debug.Log("View ID = " + gameObject.uLinkNetworkView().viewID);
            //Using the component via 'this'
            Debug.Log("View ID = " + this.uLinkNetworkView().viewID);
            </code></example>
    </member>
    <member name="T:uLink.PeerData">
      <summary>
            Data structure for holding individual host (server) information.
            </summary>
      <remarks>
            The host list retrieved from a master server uses this class to represent individual servers. 
            See <see cref="M:uLink.MasterServer.PollHostList" /></remarks>
    </member>
    <member name="F:uLink.PeerData.externalEndpoint">
      <summary>
            The public IP address and port for this host on the Internet. 
            </summary>
    </member>
    <member name="F:uLink.PeerData.ping">
      <summary>
            Returns the round trip ping time in milliseconds from the master server to the 
            game server, or if this is a WellKnownHost the ping time is instead meassured 
            between the client and the host.
            </summary>
      <remarks>
            The most usable ping time is for WellKnownHosts since it is meassured between 
            the client and the game server(s). A player is usually looking for a nearby server 
            with a nice low ping time. 
            <para>
            The ping time between the master server and the game server can be useful in some situations.
            How useful it is depends on where servers are hosted. uLink provides this value to be used in 
            any way you want.</para><para>
            If the host needs a proxy this ping time is 
            not correct. Do not use this ping time in the proxy case.  
            </para><para>
            Pingtime between a server and connected players is available via <see cref="M:uLink.Network.GetAveragePing(uLink.NetworkPlayer)" /></para></remarks>
    </member>
    <member name="P:uLink.PeerData.externalPort">
      <summary>
            Server public port, used by clients on the Internet to connect to the server.
            </summary>
    </member>
    <member name="P:uLink.PeerData.externalIP">
      <summary>
            Server public IP address, used by clients on the Internet to connect to the server.
            </summary>
    </member>
    <member name="P:uLink.PeerData.port">
      <summary>
            Server public port, used by clients on the Internet to connect to the server. Same as <see cref="P:uLink.HostData.externalPort" />.
            </summary>
    </member>
    <member name="P:uLink.PeerData.ipAddress">
      <summary>
            Server public IP address, used by clients on the Internet to connect to the server. Same as <see cref="P:uLink.HostData.externalIP" />.
            </summary>
    </member>
    <member name="T:uLink.NetworkP2P">
      <summary>
            Enables peer to peer communication between nodes. Contains implementation for the uLinkNetworkP2P script.
            </summary>
      <remarks>
            This class provides methods for creating and maintaining P2P connections. It enables peers to send
            RPC:s and transfer game objects between them. For more info, see the "P2P" chapter in the uLink manual.
            </remarks>
    </member>
    <member name="F:uLink.NetworkP2P.observed">
      <summary>
            Included here becuase <see cref="F:uLink.NetworkP2P.rpcReceiver" /> can be 
            set to <see cref="T:uLink.RPCReceiver">RPCReceiver.OnlyObservedComponent</see>. Otherwise this field is not used.
            </summary>
    </member>
    <member name="F:uLink.NetworkP2P.rpcReceiver">
      <summary>
            Gets or sets the receiver(s) for incoming RPCs to this game object.
            </summary>
      <value>Default is <see cref="T:uLink.RPCReceiver">RPCReceiver.ThisGameObject</see></value>
      <remarks>All scripts attached to the same prefab/GameObject as this
            NetworkP2P component will be able to get this RPC and can therefore contain
            code for RPC receiving. If you want to put RPC receiving code in
            scripts attached to a root gameobject or scripts attached to a child
            game object, this can be done, but this property needs to be changed
            then.</remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Connect(System.String,System.Int32)">
      <summary>
            Creates a P2P connection to another node. 
            </summary>
    </member>
    <member name="M:uLink.NetworkP2P.Connect(System.String,System.Int32,System.String)">
      <summary>
            Creates a P2P connection to another node.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2P.Connect(uLink.NetworkPeer)">
      <summary>
            Creates a P2P connection to another node.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2P.Connect(uLink.NetworkPeer,System.String)">
      <summary>
            Creates a P2P connection to another node.
            </summary>
    </member>
    <member name="M:uLink.NetworkP2P.Replicate(UnityEngine.Object,uLink.NetworkPeer)">
      <summary>
            Moves a network aware object to a remote node.
            </summary>
      <remarks>
            The object will be instantiated with a new viewId on the receiving end.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Replicate(UnityEngine.Object,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
            Moves a network aware object to a remote node.
            Adjusts the objetcs position and rotation on the receving node according to the given relative parameters.
            </summary>
      <remarks>
            The object will be instantiated with a new viewId on the receiving end.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Handover(UnityEngine.Object,uLink.NetworkPeer)">
      <summary>
            Moves a network object and it's owner to another server. 
            </summary>
      <remarks>
            Can only be invoked server-side.
            The player's client will automatically be reconnected to the new server.
            </remarks>
    </member>
    <member name="M:uLink.NetworkP2P.Handover(UnityEngine.Object,uLink.NetworkPeer,UnityEngine.Vector3,UnityEngine.Quaternion)">
      <summary>
            Moves a network object and it's owner to another server. 
            Adjusts the players position and rotation on the receving peer according to the given relative parameters.
            </summary>
      <remarks>
            Can only be invoked server-side.
            The player's client will automatically be reconnected to the new server.
            </remarks>
    </member>
    <member name="P:uLink.NetworkP2P.listenPort">
      <summary>
            The listen port for this P2P node.
            </summary>
    </member>
    <member name="P:uLink.NetworkP2P.maxConnections">
      <summary>
            Maximum allowed incoming connections for this node.
            </summary>
    </member>
    <member name="T:uLink.InternalHelper">
      <summary>
            Do not use this class. For internal use only.
            </summary>
      <remarks>Used in the internal script uLinkInternalHelper included in uLink</remarks>
    </member>
    <member name="T:uLink.NetworkVersion">
      <summary>
            The version of uLink.
            </summary>
    </member>
  </members>
</doc>